/* tslint:disable */
/* eslint-disable */
/**
 * TabT Rest
 * This api is a bridge to the TabT SOAP API. It contacts TabT and cache results in order to reduce latency for some requests. More documentation will come.<br>       The data present in the api such as player names, club names, tournaments or match results are not managed by us. This information is made freely available by the Aile Francophone de Tennis de Table and the Vlaamse Tafeltennisliga. We therefore cannot be held responsible for the publication of this information. If changes need to be made, you should contact the responsible entity.     If you build an application on top of the BePing\'s api, be sure to do at least one of the following things:         <ul><li>If possible, set a X-Application-For header string. Include the name of your application, and a way to contact you in case something would go wrong.<br>       An example user agent string format is, which could result in the following string: beping/2.0.0 (floca.be; florent@floca.be). The use of a header like this isnâ€™t obligated or enforced, but allows for better communication.</li></ul>     
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: f.cardoen@me.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'Line1': string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'Line2': string;
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    'ZipCode': number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'Town': string;
}
/**
 * 
 * @export
 * @interface AddressDTOV1
 */
export interface AddressDTOV1 {
    /**
     * 
     * @type {string}
     * @memberof AddressDTOV1
     */
    'Line1': string;
    /**
     * 
     * @type {string}
     * @memberof AddressDTOV1
     */
    'Line2': string;
    /**
     * 
     * @type {number}
     * @memberof AddressDTOV1
     */
    'ZipCode': number;
    /**
     * 
     * @type {string}
     * @memberof AddressDTOV1
     */
    'Town': string;
}
/**
 * 
 * @export
 * @interface ClubDto
 */
export interface ClubDto {
    /**
     * 
     * @type {string}
     * @memberof ClubDto
     */
    'uniqueIndex'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClubDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ClubDto
     */
    'longName': string;
    /**
     * 
     * @type {number}
     * @memberof ClubDto
     */
    'category': number;
    /**
     * 
     * @type {string}
     * @memberof ClubDto
     */
    'categoryName': string;
    /**
     * 
     * @type {number}
     * @memberof ClubDto
     */
    'venueCount': number;
    /**
     * 
     * @type {Array<VenueDto>}
     * @memberof ClubDto
     */
    'venues'?: Array<VenueDto>;
}
/**
 * 
 * @export
 * @interface CommentAuthor
 */
export interface CommentAuthor {
    /**
     * 
     * @type {number}
     * @memberof CommentAuthor
     */
    'Position'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentAuthor
     */
    'UniqueIndex'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentAuthor
     */
    'RankingIndex'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthor
     */
    'FirstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthor
     */
    'LastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthor
     */
    'Ranking'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthor
     */
    'Status'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthor
     */
    'Club'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthor
     */
    'Gender'?: string;
}
/**
 * 
 * @export
 * @interface CommentAuthorDTO
 */
export interface CommentAuthorDTO {
    /**
     * 
     * @type {number}
     * @memberof CommentAuthorDTO
     */
    'position'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentAuthorDTO
     */
    'uniqueIndex'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommentAuthorDTO
     */
    'rankingIndex'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthorDTO
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthorDTO
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthorDTO
     */
    'ranking'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthorDTO
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthorDTO
     */
    'club'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentAuthorDTO
     */
    'gender'?: CommentAuthorDTOGenderTabt;
}

export const CommentAuthorDTOGenderTabt = {
    M: 'M',
    F: 'F'
} as const;

export type CommentAuthorDTOGenderTabt = typeof CommentAuthorDTOGenderTabt[keyof typeof CommentAuthorDTOGenderTabt];

/**
 * 
 * @export
 * @interface CommentEntry
 */
export interface CommentEntry {
    /**
     * 
     * @type {string}
     * @memberof CommentEntry
     */
    'Timestamp'?: string;
    /**
     * 
     * @type {CommentAuthor}
     * @memberof CommentEntry
     */
    'Author'?: CommentAuthor;
    /**
     * 
     * @type {string}
     * @memberof CommentEntry
     */
    'Comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentEntry
     */
    'Code'?: string;
}
/**
 * 
 * @export
 * @interface CommentEntryDTO
 */
export interface CommentEntryDTO {
    /**
     * 
     * @type {string}
     * @memberof CommentEntryDTO
     */
    'timestamp'?: string;
    /**
     * 
     * @type {CommentAuthorDTO}
     * @memberof CommentEntryDTO
     */
    'author'?: CommentAuthorDTO;
    /**
     * 
     * @type {string}
     * @memberof CommentEntryDTO
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentEntryDTO
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface DayOfWeekStatsDTOV1
 */
export interface DayOfWeekStatsDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof DayOfWeekStatsDTOV1
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof DayOfWeekStatsDTOV1
     */
    'victories'?: number;
    /**
     * 
     * @type {number}
     * @memberof DayOfWeekStatsDTOV1
     */
    'defeats'?: number;
    /**
     * 
     * @type {number}
     * @memberof DayOfWeekStatsDTOV1
     */
    'victoriesPct'?: number;
    /**
     * 
     * @type {number}
     * @memberof DayOfWeekStatsDTOV1
     */
    'defeatsPct'?: number;
    /**
     * 
     * @type {string}
     * @memberof DayOfWeekStatsDTOV1
     */
    'day': string;
}
/**
 * 
 * @export
 * @interface DivisionEntryDtoV1
 */
export interface DivisionEntryDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof DivisionEntryDtoV1
     */
    'DivisionId': number;
    /**
     * 
     * @type {string}
     * @memberof DivisionEntryDtoV1
     */
    'DivisionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DivisionEntryDtoV1
     */
    'Level': DivisionEntryDtoV1LevelTabt;
    /**
     * 
     * @type {number}
     * @memberof DivisionEntryDtoV1
     */
    'MatchType': number;
    /**
     * 
     * @type {string}
     * @memberof DivisionEntryDtoV1
     */
    'DivisionCategory'?: DivisionEntryDtoV1DivisionCategoryTabt;
    /**
     * 
     * @type {string}
     * @memberof DivisionEntryDtoV1
     */
    'PlayerCategory'?: DivisionEntryDtoV1PlayerCategoryTabt;
}

export const DivisionEntryDtoV1LevelTabt = {
    SuperDivision: 'SUPER_DIVISION',
    National: 'NATIONAL',
    RegionVttl: 'REGION_VTTL',
    Antwerp: 'ANTWERP',
    Limburg: 'LIMBURG',
    OostVlanderen: 'OOST_VLANDEREN',
    WestVlaanderen: 'WEST_VLAANDEREN',
    VlaamsBrabantBr: 'VLAAMS_BRABANT_BR',
    Hainaut: 'HAINAUT',
    Liege: 'LIEGE',
    Luxembourg: 'LUXEMBOURG',
    Namur: 'NAMUR',
    BrusselsBrabantWallon: 'BRUSSELS_BRABANT_WALLON',
    Brussels: 'BRUSSELS',
    Iwb: 'IWB'
} as const;

export type DivisionEntryDtoV1LevelTabt = typeof DivisionEntryDtoV1LevelTabt[keyof typeof DivisionEntryDtoV1LevelTabt];
export const DivisionEntryDtoV1DivisionCategoryTabt = {
    SenM: 'SEN_M',
    SenW: 'SEN_W',
    YouM: 'YOU_M',
    YouW: 'YOU_W'
} as const;

export type DivisionEntryDtoV1DivisionCategoryTabt = typeof DivisionEntryDtoV1DivisionCategoryTabt[keyof typeof DivisionEntryDtoV1DivisionCategoryTabt];
export const DivisionEntryDtoV1PlayerCategoryTabt = {
    SenM: 'SEN_M',
    SenW: 'SEN_W',
    YouM: 'YOU_M',
    YouW: 'YOU_W',
    VetM: 'VET_M',
    VetW: 'VET_W',
    BenM: 'BEN_M',
    BenW: 'BEN_W',
    PreM: 'PRE_M',
    PreW: 'PRE_W',
    MinM: 'MIN_M',
    MinW: 'MIN_W',
    CadM: 'CAD_M',
    CadW: 'CAD_W',
    JunM: 'JUN_M',
    JunW: 'JUN_W',
    J19M: 'J19_M',
    J19W: 'J19_W',
    V40M: 'V40_M',
    V40W: 'V40_W',
    V50M: 'V50_M',
    V50W: 'V50_W',
    V60M: 'V60_M',
    V60W: 'V60_W',
    V65M: 'V65_M',
    V65W: 'V65_W',
    V70M: 'V70_M',
    V70W: 'V70_W',
    V75M: 'V75_M',
    V75W: 'V75_W',
    V80M: 'V80_M',
    V80W: 'V80_W',
    V85M: 'V85_M',
    V85W: 'V85_W'
} as const;

export type DivisionEntryDtoV1PlayerCategoryTabt = typeof DivisionEntryDtoV1PlayerCategoryTabt[keyof typeof DivisionEntryDtoV1PlayerCategoryTabt];

/**
 * 
 * @export
 * @interface DoubleTeam
 */
export interface DoubleTeam {
    /**
     * 
     * @type {number}
     * @memberof DoubleTeam
     */
    'Position': number;
    /**
     * 
     * @type {string}
     * @memberof DoubleTeam
     */
    'Team': string;
    /**
     * 
     * @type {boolean}
     * @memberof DoubleTeam
     */
    'IsForfeited': boolean;
}
/**
 * 
 * @export
 * @interface DoubleTeamDTO
 */
export interface DoubleTeamDTO {
    /**
     * 
     * @type {number}
     * @memberof DoubleTeamDTO
     */
    'position'?: number;
    /**
     * 
     * @type {string}
     * @memberof DoubleTeamDTO
     */
    'team'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DoubleTeamDTO
     */
    'isForfeited'?: boolean;
}
/**
 * 
 * @export
 * @interface Head2HeadData
 */
export interface Head2HeadData {
    /**
     * 
     * @type {number}
     * @memberof Head2HeadData
     */
    'head2HeadCount': number;
    /**
     * 
     * @type {number}
     * @memberof Head2HeadData
     */
    'victoryCount': number;
    /**
     * 
     * @type {number}
     * @memberof Head2HeadData
     */
    'defeatCount': number;
    /**
     * 
     * @type {string}
     * @memberof Head2HeadData
     */
    'lastVictory'?: string;
    /**
     * 
     * @type {string}
     * @memberof Head2HeadData
     */
    'lastDefeat'?: string;
    /**
     * 
     * @type {string}
     * @memberof Head2HeadData
     */
    'firstVictory'?: string;
    /**
     * 
     * @type {Array<MatchEntryHistory>}
     * @memberof Head2HeadData
     */
    'matchEntryHistory': Array<MatchEntryHistory>;
    /**
     * 
     * @type {PlayersInfo}
     * @memberof Head2HeadData
     */
    'playersInfo': PlayersInfo;
}
/**
 * 
 * @export
 * @interface IndividualMatchResult
 */
export interface IndividualMatchResult {
    /**
     * 
     * @type {number}
     * @memberof IndividualMatchResult
     */
    'Position': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof IndividualMatchResult
     */
    'HomePlayerMatchIndex': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof IndividualMatchResult
     */
    'HomePlayerUniqueIndex': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof IndividualMatchResult
     */
    'AwayPlayerMatchIndex': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof IndividualMatchResult
     */
    'AwayPlayerUniqueIndex': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof IndividualMatchResult
     */
    'HomeSetCount': number;
    /**
     * 
     * @type {number}
     * @memberof IndividualMatchResult
     */
    'AwaySetCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof IndividualMatchResult
     */
    'IsHomeForfeited'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IndividualMatchResult
     */
    'IsAwayForfeited'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IndividualMatchResult
     */
    'Scores'?: string;
}
/**
 * 
 * @export
 * @interface IndividualMatchResultDTO
 */
export interface IndividualMatchResultDTO {
    /**
     * 
     * @type {number}
     * @memberof IndividualMatchResultDTO
     */
    'position'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof IndividualMatchResultDTO
     */
    'homePlayerMatchIndex'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof IndividualMatchResultDTO
     */
    'homePlayerUniqueIndex'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof IndividualMatchResultDTO
     */
    'awayPlayerMatchIndex'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof IndividualMatchResultDTO
     */
    'awayPlayerUniqueIndex'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof IndividualMatchResultDTO
     */
    'homeSetCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof IndividualMatchResultDTO
     */
    'awaySetCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IndividualMatchResultDTO
     */
    'isHomeForfeited'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IndividualMatchResultDTO
     */
    'isAwayForfeited'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IndividualMatchResultDTO
     */
    'scores'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof InlineResponse200
     */
    'info'?: { [key: string]: { [key: string]: object; }; } | null;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof InlineResponse200
     */
    'error'?: { [key: string]: { [key: string]: object; }; } | null;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof InlineResponse200
     */
    'details'?: { [key: string]: { [key: string]: object; }; };
}
/**
 * 
 * @export
 * @interface InlineResponse503
 */
export interface InlineResponse503 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse503
     */
    'status'?: string;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof InlineResponse503
     */
    'info'?: { [key: string]: { [key: string]: object; }; } | null;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof InlineResponse503
     */
    'error'?: { [key: string]: { [key: string]: object; }; } | null;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof InlineResponse503
     */
    'details'?: { [key: string]: { [key: string]: object; }; };
}
/**
 * 
 * @export
 * @interface InternalIdentifiersDTO
 */
export interface InternalIdentifiersDTO {
    /**
     * 
     * @type {number}
     * @memberof InternalIdentifiersDTO
     */
    'clubInternalIdentifier': number;
    /**
     * 
     * @type {number}
     * @memberof InternalIdentifiersDTO
     */
    'playerInternalIdentifier': number;
}
/**
 * 
 * @export
 * @interface MatchDetails
 */
export interface MatchDetails {
    /**
     * 
     * @type {boolean}
     * @memberof MatchDetails
     */
    'DetailsCreated': boolean;
    /**
     * 
     * @type {string}
     * @memberof MatchDetails
     */
    'StartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchDetails
     */
    'EndTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchDetails
     */
    'HomeCaptain'?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetails
     */
    'AwayCaptain'?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetails
     */
    'Referee'?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetails
     */
    'HallCommissioner'?: number;
    /**
     * 
     * @type {Players}
     * @memberof MatchDetails
     */
    'HomePlayers': Players;
    /**
     * 
     * @type {Players}
     * @memberof MatchDetails
     */
    'AwayPlayers': Players;
    /**
     * 
     * @type {Array<IndividualMatchResult>}
     * @memberof MatchDetails
     */
    'IndividualMatchResults': Array<IndividualMatchResult>;
    /**
     * 
     * @type {number}
     * @memberof MatchDetails
     */
    'MatchSystem': number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetails
     */
    'HomeScore': number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetails
     */
    'AwayScore': number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetails
     */
    'CommentCount': number;
    /**
     * 
     * @type {Array<CommentEntry>}
     * @memberof MatchDetails
     */
    'CommentEntries'?: Array<CommentEntry>;
}
/**
 * 
 * @export
 * @interface MatchDetailsDTO
 */
export interface MatchDetailsDTO {
    /**
     * 
     * @type {boolean}
     * @memberof MatchDetailsDTO
     */
    'detailsCreated': boolean;
    /**
     * 
     * @type {string}
     * @memberof MatchDetailsDTO
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchDetailsDTO
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTO
     */
    'homeCaptain'?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTO
     */
    'awayCaptain'?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTO
     */
    'referee'?: number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTO
     */
    'hallCommissioner'?: number;
    /**
     * 
     * @type {PlayersDTO}
     * @memberof MatchDetailsDTO
     */
    'homePlayers'?: PlayersDTO;
    /**
     * 
     * @type {PlayersDTO}
     * @memberof MatchDetailsDTO
     */
    'awayPlayers'?: PlayersDTO;
    /**
     * 
     * @type {Array<IndividualMatchResultDTO>}
     * @memberof MatchDetailsDTO
     */
    'individualMatchResults'?: Array<IndividualMatchResultDTO>;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTO
     */
    'matchSystem': number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTO
     */
    'homeScore': number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTO
     */
    'awayScore': number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTO
     */
    'commentCount': number;
    /**
     * 
     * @type {Array<CommentEntryDTO>}
     * @memberof MatchDetailsDTO
     */
    'commentEntries'?: Array<CommentEntryDTO>;
}
/**
 * 
 * @export
 * @interface MatchDetailsDTOV1
 */
export interface MatchDetailsDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTOV1
     */
    'averageSetsPerMatch': number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTOV1
     */
    'cleanVictories': number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTOV1
     */
    'cleanDefeats': number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTOV1
     */
    'comebacks': number;
    /**
     * 
     * @type {number}
     * @memberof MatchDetailsDTOV1
     */
    'leadLost': number;
}
/**
 * 
 * @export
 * @interface MatchEntryHistory
 */
export interface MatchEntryHistory {
    /**
     * 
     * @type {number}
     * @memberof MatchEntryHistory
     */
    'season'?: number;
    /**
     * 
     * @type {string}
     * @memberof MatchEntryHistory
     */
    'date': string;
    /**
     * 
     * @type {TeamMatchesEntry}
     * @memberof MatchEntryHistory
     */
    'matchEntry': TeamMatchesEntry;
    /**
     * 
     * @type {string}
     * @memberof MatchEntryHistory
     */
    'playerRanking': string;
    /**
     * 
     * @type {string}
     * @memberof MatchEntryHistory
     */
    'opponentRanking': string;
    /**
     * 
     * @type {string}
     * @memberof MatchEntryHistory
     */
    'score': string;
}
/**
 * 
 * @export
 * @interface MatchHistoryEntryDTOV1
 */
export interface MatchHistoryEntryDTOV1 {
    /**
     * 
     * @type {string}
     * @memberof MatchHistoryEntryDTOV1
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof MatchHistoryEntryDTOV1
     */
    'result': MatchHistoryEntryDTOV1ResultTabt;
    /**
     * 
     * @type {string}
     * @memberof MatchHistoryEntryDTOV1
     */
    'opponentName': string;
    /**
     * 
     * @type {string}
     * @memberof MatchHistoryEntryDTOV1
     */
    'opponentRanking': string;
    /**
     * 
     * @type {string}
     * @memberof MatchHistoryEntryDTOV1
     */
    'score': string;
}

export const MatchHistoryEntryDTOV1ResultTabt = {
    V: 'V',
    D: 'D'
} as const;

export type MatchHistoryEntryDTOV1ResultTabt = typeof MatchHistoryEntryDTOV1ResultTabt[keyof typeof MatchHistoryEntryDTOV1ResultTabt];

/**
 * 
 * @export
 * @interface MatchSystemEntry
 */
export interface MatchSystemEntry {
    /**
     * 
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'UniqueIndex': number;
    /**
     * 
     * @type {string}
     * @memberof MatchSystemEntry
     */
    'Name': string;
    /**
     * 
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'SingleMatchCount': number;
    /**
     * 
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'DoubleMatchCount': number;
    /**
     * 
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'SetCount': number;
    /**
     * 
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'PointCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof MatchSystemEntry
     */
    'ForcedDoubleTeams': boolean;
    /**
     * 
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'SubstituteCount': number;
    /**
     * 
     * @type {number}
     * @memberof MatchSystemEntry
     */
    'TeamMatchCount': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MatchSystemEntry
     */
    'TeamMatchDefinitionEntries': Array<string>;
}
/**
 * 
 * @export
 * @interface MemberDashboardDTOV1
 */
export interface MemberDashboardDTOV1 {
    /**
     * The status of the response
     * @type {ResponseDTO}
     * @memberof MemberDashboardDTOV1
     */
    'status': ResponseDTO;
    /**
     * The member data
     * @type {MemberEntry}
     * @memberof MemberDashboardDTOV1
     */
    'member': MemberEntry;
    /**
     * The numeric ranking response
     * @type {WeeklyRankingV1Response}
     * @memberof MemberDashboardDTOV1
     */
    'numericRanking': WeeklyRankingV1Response;
    /**
     * The latest team matches
     * @type {Array<TeamMatchesEntry>}
     * @memberof MemberDashboardDTOV1
     */
    'latestTeamMatches': Array<TeamMatchesEntry>;
    /**
     * The statistics of the member
     * @type {MemberStatsDTOV1}
     * @memberof MemberDashboardDTOV1
     */
    'stats': MemberStatsDTOV1;
    /**
     * 
     * @type {NextMatchEstimationDTO}
     * @memberof MemberDashboardDTOV1
     */
    'nextMatchEstimation'?: NextMatchEstimationDTO;
}
/**
 * 
 * @export
 * @interface MemberEntry
 */
export interface MemberEntry {
    /**
     * 
     * @type {number}
     * @memberof MemberEntry
     */
    'Position': number;
    /**
     * 
     * @type {number}
     * @memberof MemberEntry
     */
    'UniqueIndex': number;
    /**
     * 
     * @type {number}
     * @memberof MemberEntry
     */
    'RankingIndex': number;
    /**
     * 
     * @type {string}
     * @memberof MemberEntry
     */
    'FirstName': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntry
     */
    'LastName': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntry
     */
    'Ranking': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntry
     */
    'Status': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntry
     */
    'Club': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntry
     */
    'Gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntry
     */
    'Category'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntry
     */
    'BirthDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MemberEntry
     */
    'MedicalAttestation'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MemberEntry
     */
    'RankingPointsCount'?: number;
    /**
     * 
     * @type {Array<RankingPointsEntry>}
     * @memberof MemberEntry
     */
    'RankingPointsEntries'?: Array<RankingPointsEntry>;
    /**
     * 
     * @type {string}
     * @memberof MemberEntry
     */
    'Email'?: string;
    /**
     * 
     * @type {Phone}
     * @memberof MemberEntry
     */
    'Phone'?: Phone;
    /**
     * 
     * @type {Address}
     * @memberof MemberEntry
     */
    'Address'?: Address;
    /**
     * 
     * @type {number}
     * @memberof MemberEntry
     */
    'ResultCount'?: number;
    /**
     * 
     * @type {Array<MemberEntryResultEntry>}
     * @memberof MemberEntry
     */
    'ResultEntries'?: Array<MemberEntryResultEntry>;
    /**
     * 
     * @type {string}
     * @memberof MemberEntry
     */
    'NationalNumber'?: string;
}
/**
 * 
 * @export
 * @interface MemberEntryDTOV1
 */
export interface MemberEntryDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof MemberEntryDTOV1
     */
    'Position': number;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryDTOV1
     */
    'UniqueIndex': number;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryDTOV1
     */
    'RankingIndex': number;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryDTOV1
     */
    'FirstName': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryDTOV1
     */
    'LastName': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryDTOV1
     */
    'Ranking': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryDTOV1
     */
    'Status': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryDTOV1
     */
    'Club': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryDTOV1
     */
    'Gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryDTOV1
     */
    'Category'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryDTOV1
     */
    'BirthDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MemberEntryDTOV1
     */
    'MedicalAttestation'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryDTOV1
     */
    'RankingPointsCount'?: number;
    /**
     * 
     * @type {Array<RankingPointsEntryDTOV1>}
     * @memberof MemberEntryDTOV1
     */
    'RankingPointsEntries'?: Array<RankingPointsEntryDTOV1>;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryDTOV1
     */
    'Email'?: string;
    /**
     * 
     * @type {PhoneDTOV1}
     * @memberof MemberEntryDTOV1
     */
    'Phone'?: PhoneDTOV1;
    /**
     * 
     * @type {AddressDTOV1}
     * @memberof MemberEntryDTOV1
     */
    'Address'?: AddressDTOV1;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryDTOV1
     */
    'ResultCount'?: number;
    /**
     * 
     * @type {Array<MemberEntryResultEntryDTOV1>}
     * @memberof MemberEntryDTOV1
     */
    'ResultEntries'?: Array<MemberEntryResultEntryDTOV1>;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryDTOV1
     */
    'NationalNumber'?: string;
}
/**
 * 
 * @export
 * @interface MemberEntryResultEntry
 */
export interface MemberEntryResultEntry {
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'Date': string;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryResultEntry
     */
    'UniqueIndex': number;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'FirstName': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'LastName': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'Ranking': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'Result': string;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryResultEntry
     */
    'SetFor': number;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryResultEntry
     */
    'SetAgainst': number;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'CompetitionType': MemberEntryResultEntryCompetitionTypeTabt;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'Club': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'MatchId'?: string;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryResultEntry
     */
    'MatchUniqueId'?: number;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'TournamentName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'TournamentSerieName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntry
     */
    'TeamName'?: string;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryResultEntry
     */
    'RankingEvaluationCount'?: number;
    /**
     * 
     * @type {Array<RankingEvaluationEntry>}
     * @memberof MemberEntryResultEntry
     */
    'RankingEvaluationEntries'?: Array<RankingEvaluationEntry>;
}

export const MemberEntryResultEntryCompetitionTypeTabt = {
    C: 'C',
    T: 'T'
} as const;

export type MemberEntryResultEntryCompetitionTypeTabt = typeof MemberEntryResultEntryCompetitionTypeTabt[keyof typeof MemberEntryResultEntryCompetitionTypeTabt];

/**
 * 
 * @export
 * @interface MemberEntryResultEntryDTOV1
 */
export interface MemberEntryResultEntryDTOV1 {
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'Date': string;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'UniqueIndex': number;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'FirstName': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'LastName': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'Ranking': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'Result': string;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'SetFor': number;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'SetAgainst': number;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'CompetitionType': MemberEntryResultEntryDTOV1CompetitionTypeTabt;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'Club': string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'MatchId'?: string;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'MatchUniqueId'?: number;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'TournamentName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'TournamentSerieName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'TeamName'?: string;
    /**
     * 
     * @type {number}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'RankingEvaluationCount'?: number;
    /**
     * 
     * @type {Array<RankingEvaluationEntryDTOV1>}
     * @memberof MemberEntryResultEntryDTOV1
     */
    'RankingEvaluationEntries'?: Array<RankingEvaluationEntryDTOV1>;
}

export const MemberEntryResultEntryDTOV1CompetitionTypeTabt = {
    C: 'C',
    T: 'T'
} as const;

export type MemberEntryResultEntryDTOV1CompetitionTypeTabt = typeof MemberEntryResultEntryDTOV1CompetitionTypeTabt[keyof typeof MemberEntryResultEntryDTOV1CompetitionTypeTabt];

/**
 * 
 * @export
 * @interface MemberStatsDTOV1
 */
export interface MemberStatsDTOV1 {
    /**
     * 
     * @type {WinLossSummaryDTOV1}
     * @memberof MemberStatsDTOV1
     */
    'tieBreaks': WinLossSummaryDTOV1;
    /**
     * 
     * @type {WinLossSummaryDTOV1}
     * @memberof MemberStatsDTOV1
     */
    'matches': WinLossSummaryDTOV1;
    /**
     * 
     * @type {Array<RankingWinLossDTOV1>}
     * @memberof MemberStatsDTOV1
     */
    'perRanking': Array<RankingWinLossDTOV1>;
    /**
     * 
     * @type {SetStatsDTOV1}
     * @memberof MemberStatsDTOV1
     */
    'sets': SetStatsDTOV1;
    /**
     * 
     * @type {StreakDTOV1}
     * @memberof MemberStatsDTOV1
     */
    'winStreak': StreakDTOV1;
    /**
     * 
     * @type {StreakDTOV1}
     * @memberof MemberStatsDTOV1
     */
    'lossStreak': StreakDTOV1;
    /**
     * 
     * @type {SeasonExtremesDTOV1}
     * @memberof MemberStatsDTOV1
     */
    'seasonExtremes': SeasonExtremesDTOV1;
    /**
     * 
     * @type {Array<MatchHistoryEntryDTOV1>}
     * @memberof MemberStatsDTOV1
     */
    'matchHistory': Array<MatchHistoryEntryDTOV1>;
    /**
     * 
     * @type {Array<TimeOfDayStatsDTOV1>}
     * @memberof MemberStatsDTOV1
     */
    'timeOfDay': Array<TimeOfDayStatsDTOV1>;
    /**
     * 
     * @type {Array<DayOfWeekStatsDTOV1>}
     * @memberof MemberStatsDTOV1
     */
    'dayOfWeek': Array<DayOfWeekStatsDTOV1>;
    /**
     * 
     * @type {Array<MonthlyStatsDTOV1>}
     * @memberof MemberStatsDTOV1
     */
    'monthly': Array<MonthlyStatsDTOV1>;
    /**
     * 
     * @type {MatchDetailsDTOV1}
     * @memberof MemberStatsDTOV1
     */
    'matchDetails': MatchDetailsDTOV1;
}
/**
 * 
 * @export
 * @interface MonthlyStatsDTOV1
 */
export interface MonthlyStatsDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof MonthlyStatsDTOV1
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof MonthlyStatsDTOV1
     */
    'victories'?: number;
    /**
     * 
     * @type {number}
     * @memberof MonthlyStatsDTOV1
     */
    'defeats'?: number;
    /**
     * 
     * @type {number}
     * @memberof MonthlyStatsDTOV1
     */
    'victoriesPct'?: number;
    /**
     * 
     * @type {number}
     * @memberof MonthlyStatsDTOV1
     */
    'defeatsPct'?: number;
    /**
     * 
     * @type {string}
     * @memberof MonthlyStatsDTOV1
     */
    'month': string;
}
/**
 * 
 * @export
 * @interface MultiCategoryMemberDashboardDTOV1
 */
export interface MultiCategoryMemberDashboardDTOV1 {
    /**
     * The status of the response
     * @type {ResponseDTO}
     * @memberof MultiCategoryMemberDashboardDTOV1
     */
    'status': ResponseDTO;
    /**
     * Dashboard data for SENIOR_MEN category
     * @type {MemberDashboardDTOV1}
     * @memberof MultiCategoryMemberDashboardDTOV1
     */
    'SENIOR_MEN'?: MemberDashboardDTOV1;
    /**
     * Dashboard data for SENIOR_WOMEN category
     * @type {MemberDashboardDTOV1}
     * @memberof MultiCategoryMemberDashboardDTOV1
     */
    'SENIOR_WOMEN'?: MemberDashboardDTOV1;
    /**
     * List of categories where the member exists
     * @type {Array<string>}
     * @memberof MultiCategoryMemberDashboardDTOV1
     */
    'availableCategories': Array<string>;
}
/**
 * 
 * @export
 * @interface NextMatchEstimationDTO
 */
export interface NextMatchEstimationDTO {
    /**
     * 
     * @type {string}
     * @memberof NextMatchEstimationDTO
     */
    'matchId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NextMatchEstimationDTO
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof NextMatchEstimationDTO
     */
    'homeTeam'?: string;
    /**
     * 
     * @type {string}
     * @memberof NextMatchEstimationDTO
     */
    'awayTeam'?: string;
    /**
     * Best case scenario - most points to win
     * @type {Array<OpponentEstimationDTO>}
     * @memberof NextMatchEstimationDTO
     */
    'bestCase': Array<OpponentEstimationDTO>;
    /**
     * Worst case scenario - least points to win
     * @type {Array<OpponentEstimationDTO>}
     * @memberof NextMatchEstimationDTO
     */
    'worstCase': Array<OpponentEstimationDTO>;
}
/**
 * 
 * @export
 * @interface NumericRankingDetailsV1
 */
export interface NumericRankingDetailsV1 {
    /**
     * 
     * @type {string}
     * @memberof NumericRankingDetailsV1
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof NumericRankingDetailsV1
     */
    'competitionType': NumericRankingDetailsV1CompetitionTypeTabt;
    /**
     * 
     * @type {string}
     * @memberof NumericRankingDetailsV1
     */
    'competitionContext': string;
    /**
     * 
     * @type {number}
     * @memberof NumericRankingDetailsV1
     */
    'basePoints': number;
    /**
     * 
     * @type {number}
     * @memberof NumericRankingDetailsV1
     */
    'endPoints': number;
    /**
     * 
     * @type {Array<NumericRankingPerWeekOpponentsV1>}
     * @memberof NumericRankingDetailsV1
     */
    'opponents': Array<NumericRankingPerWeekOpponentsV1>;
}

export const NumericRankingDetailsV1CompetitionTypeTabt = {
    Championship: 'championship',
    Tournament: 'tournament'
} as const;

export type NumericRankingDetailsV1CompetitionTypeTabt = typeof NumericRankingDetailsV1CompetitionTypeTabt[keyof typeof NumericRankingDetailsV1CompetitionTypeTabt];

/**
 * 
 * @export
 * @interface NumericRankingPerWeekOpponentsV1
 */
export interface NumericRankingPerWeekOpponentsV1 {
    /**
     * 
     * @type {string}
     * @memberof NumericRankingPerWeekOpponentsV1
     */
    'opponentName': string;
    /**
     * 
     * @type {number}
     * @memberof NumericRankingPerWeekOpponentsV1
     */
    'opponentUniqueIndex': number;
    /**
     * 
     * @type {string}
     * @memberof NumericRankingPerWeekOpponentsV1
     */
    'opponentRanking': string;
    /**
     * 
     * @type {number}
     * @memberof NumericRankingPerWeekOpponentsV1
     */
    'opponentNumericPoints': number;
    /**
     * 
     * @type {number}
     * @memberof NumericRankingPerWeekOpponentsV1
     */
    'pointsWon': number;
    /**
     * 
     * @type {string}
     * @memberof NumericRankingPerWeekOpponentsV1
     */
    'score': string;
}
/**
 * 
 * @export
 * @interface OpponentEstimationDTO
 */
export interface OpponentEstimationDTO {
    /**
     * 
     * @type {string}
     * @memberof OpponentEstimationDTO
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof OpponentEstimationDTO
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof OpponentEstimationDTO
     */
    'ranking': string;
    /**
     * 
     * @type {number}
     * @memberof OpponentEstimationDTO
     */
    'pointsToWin': number;
    /**
     * 
     * @type {number}
     * @memberof OpponentEstimationDTO
     */
    'coefficient': number;
    /**
     * 
     * @type {boolean}
     * @memberof OpponentEstimationDTO
     */
    'isExpectedWin': boolean;
    /**
     * 
     * @type {number}
     * @memberof OpponentEstimationDTO
     */
    'pointsDifference': number;
}
/**
 * 
 * @export
 * @interface Phone
 */
export interface Phone {
    /**
     * 
     * @type {string}
     * @memberof Phone
     */
    'Home': string;
    /**
     * 
     * @type {string}
     * @memberof Phone
     */
    'Work': string;
    /**
     * 
     * @type {string}
     * @memberof Phone
     */
    'Mobile': string;
    /**
     * 
     * @type {string}
     * @memberof Phone
     */
    'Fax': string;
}
/**
 * 
 * @export
 * @interface PhoneDTOV1
 */
export interface PhoneDTOV1 {
    /**
     * 
     * @type {string}
     * @memberof PhoneDTOV1
     */
    'Home': string;
    /**
     * 
     * @type {string}
     * @memberof PhoneDTOV1
     */
    'Work': string;
    /**
     * 
     * @type {string}
     * @memberof PhoneDTOV1
     */
    'Mobile': string;
    /**
     * 
     * @type {string}
     * @memberof PhoneDTOV1
     */
    'Fax': string;
}
/**
 * 
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    'Position': number;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    'UniqueIndex': number;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    'FirstName': string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    'LastName': string;
    /**
     * 
     * @type {string}
     * @memberof Player
     */
    'Ranking': string;
    /**
     * 
     * @type {number}
     * @memberof Player
     */
    'VictoryCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Player
     */
    'IsForfeited'?: boolean;
}
/**
 * 
 * @export
 * @interface PlayerDTO
 */
export interface PlayerDTO {
    /**
     * 
     * @type {number}
     * @memberof PlayerDTO
     */
    'position': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerDTO
     */
    'uniqueIndex': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerDTO
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerDTO
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerDTO
     */
    'ranking': string;
    /**
     * 
     * @type {number}
     * @memberof PlayerDTO
     */
    'victoryCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerDTO
     */
    'isForfeited'?: boolean;
}
/**
 * 
 * @export
 * @interface PlayerMatchStats
 */
export interface PlayerMatchStats {
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchStats
     */
    'played': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchStats
     */
    'win': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchStats
     */
    'lose': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchStats
     */
    'uniqueIndex': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerMatchStats
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerMatchStats
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerMatchStats
     */
    'ranking': string;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchStats
     */
    'winPourcentage': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchStats
     */
    'losePourcentage': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerMatchStats
     */
    'club': string;
}
/**
 * 
 * @export
 * @interface Players
 */
export interface Players {
    /**
     * 
     * @type {number}
     * @memberof Players
     */
    'PlayerCount': number;
    /**
     * 
     * @type {number}
     * @memberof Players
     */
    'DoubleTeamCount': number;
    /**
     * 
     * @type {Array<Player>}
     * @memberof Players
     */
    'Players'?: Array<Player>;
    /**
     * 
     * @type {Array<DoubleTeam>}
     * @memberof Players
     */
    'DoubleTeams'?: Array<DoubleTeam>;
}
/**
 * 
 * @export
 * @interface PlayersDTO
 */
export interface PlayersDTO {
    /**
     * 
     * @type {number}
     * @memberof PlayersDTO
     */
    'playerCount': number;
    /**
     * 
     * @type {number}
     * @memberof PlayersDTO
     */
    'doubleTeamCount': number;
    /**
     * 
     * @type {Array<PlayerDTO>}
     * @memberof PlayersDTO
     */
    'players'?: Array<PlayerDTO>;
    /**
     * 
     * @type {Array<DoubleTeamDTO>}
     * @memberof PlayersDTO
     */
    'doubleTeams'?: Array<DoubleTeamDTO>;
}
/**
 * 
 * @export
 * @interface PlayersInfo
 */
export interface PlayersInfo {
    /**
     * 
     * @type {number}
     * @memberof PlayersInfo
     */
    'playerUniqueIndex': number;
    /**
     * 
     * @type {number}
     * @memberof PlayersInfo
     */
    'opponentPlayerUniqueIndex': number;
    /**
     * 
     * @type {string}
     * @memberof PlayersInfo
     */
    'playerName': string;
    /**
     * 
     * @type {string}
     * @memberof PlayersInfo
     */
    'opponentPlayerName': string;
}
/**
 * 
 * @export
 * @interface RankingEntryDtoV1
 */
export interface RankingEntryDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof RankingEntryDtoV1
     */
    'team': string;
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'gamesPlayed': number;
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'gamesWon': number;
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'gamesLost': number;
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'gamesDraw': number;
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'gamesWO': number;
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'individualMatchesWon': number;
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'individualMatchesLost': number;
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'individualSetsWon': number;
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'individualSetsLost': number;
    /**
     * 
     * @type {number}
     * @memberof RankingEntryDtoV1
     */
    'points': number;
    /**
     * 
     * @type {string}
     * @memberof RankingEntryDtoV1
     */
    'teamClub': string;
}
/**
 * 
 * @export
 * @interface RankingEvaluationEntry
 */
export interface RankingEvaluationEntry {
    /**
     * 
     * @type {string}
     * @memberof RankingEvaluationEntry
     */
    'EvaluationType': string;
    /**
     * 
     * @type {string}
     * @memberof RankingEvaluationEntry
     */
    'EvaluationValue': string;
}
/**
 * 
 * @export
 * @interface RankingEvaluationEntryDTOV1
 */
export interface RankingEvaluationEntryDTOV1 {
    /**
     * 
     * @type {string}
     * @memberof RankingEvaluationEntryDTOV1
     */
    'EvaluationType': string;
    /**
     * 
     * @type {string}
     * @memberof RankingEvaluationEntryDTOV1
     */
    'EvaluationValue': string;
}
/**
 * 
 * @export
 * @interface RankingPointsEntry
 */
export interface RankingPointsEntry {
    /**
     * 
     * @type {string}
     * @memberof RankingPointsEntry
     */
    'MethodName': string;
    /**
     * 
     * @type {string}
     * @memberof RankingPointsEntry
     */
    'Value': string;
    /**
     * 
     * @type {string}
     * @memberof RankingPointsEntry
     */
    'LastModified': string;
}
/**
 * 
 * @export
 * @interface RankingPointsEntryDTOV1
 */
export interface RankingPointsEntryDTOV1 {
    /**
     * 
     * @type {string}
     * @memberof RankingPointsEntryDTOV1
     */
    'MethodName': string;
    /**
     * 
     * @type {string}
     * @memberof RankingPointsEntryDTOV1
     */
    'Value': string;
    /**
     * 
     * @type {string}
     * @memberof RankingPointsEntryDTOV1
     */
    'LastModified': string;
}
/**
 * 
 * @export
 * @interface RankingWinLossDTOV1
 */
export interface RankingWinLossDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof RankingWinLossDTOV1
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof RankingWinLossDTOV1
     */
    'victories'?: number;
    /**
     * 
     * @type {number}
     * @memberof RankingWinLossDTOV1
     */
    'defeats'?: number;
    /**
     * 
     * @type {number}
     * @memberof RankingWinLossDTOV1
     */
    'victoriesPct'?: number;
    /**
     * 
     * @type {number}
     * @memberof RankingWinLossDTOV1
     */
    'defeatsPct'?: number;
    /**
     * 
     * @type {string}
     * @memberof RankingWinLossDTOV1
     */
    'ranking': string;
    /**
     * 
     * @type {Array<MemberEntryResultEntry>}
     * @memberof RankingWinLossDTOV1
     */
    'players': Array<MemberEntryResultEntry>;
}
/**
 * 
 * @export
 * @interface RedirectLinkDTO
 */
export interface RedirectLinkDTO {
    /**
     * 
     * @type {string}
     * @memberof RedirectLinkDTO
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RegisterTournament
 */
export interface RegisterTournament {
    /**
     * 
     * @type {Array<string>}
     * @memberof RegisterTournament
     */
    'playerUniqueIndex': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterTournament
     */
    'unregister': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterTournament
     */
    'notifyPlayer': boolean;
}
/**
 * 
 * @export
 * @interface ResponseDTO
 */
export interface ResponseDTO {
    /**
     * The status of the response
     * @type {string}
     * @memberof ResponseDTO
     */
    'status': string;
    /**
     * The payload of the response
     * @type {object}
     * @memberof ResponseDTO
     */
    'payload': object;
    /**
     * The error message, if any
     * @type {string}
     * @memberof ResponseDTO
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface SearchResultDTO
 */
export interface SearchResultDTO {
    /**
     * 
     * @type {Array<MemberEntryDTOV1>}
     * @memberof SearchResultDTO
     */
    'members'?: Array<MemberEntryDTOV1>;
    /**
     * 
     * @type {Array<ClubDto>}
     * @memberof SearchResultDTO
     */
    'clubs'?: Array<ClubDto>;
    /**
     * 
     * @type {Array<TournamentEntryDTOV1>}
     * @memberof SearchResultDTO
     */
    'tournaments'?: Array<TournamentEntryDTOV1>;
}
/**
 * 
 * @export
 * @interface SeasonDto
 */
export interface SeasonDto {
    /**
     * The unique identifier of the season
     * @type {number}
     * @memberof SeasonDto
     */
    'season': number;
    /**
     * The name of the season
     * @type {string}
     * @memberof SeasonDto
     */
    'name': string;
    /**
     * Whether this is the current season
     * @type {boolean}
     * @memberof SeasonDto
     */
    'isCurrent': boolean;
}
/**
 * 
 * @export
 * @interface SeasonExtremesDTOV1
 */
export interface SeasonExtremesDTOV1 {
    /**
     * 
     * @type {string}
     * @memberof SeasonExtremesDTOV1
     */
    'highestRanking': string;
    /**
     * 
     * @type {string}
     * @memberof SeasonExtremesDTOV1
     */
    'lowestRanking': string;
    /**
     * 
     * @type {number}
     * @memberof SeasonExtremesDTOV1
     */
    'highestPoints'?: number;
    /**
     * 
     * @type {number}
     * @memberof SeasonExtremesDTOV1
     */
    'lowestPoints'?: number;
    /**
     * 
     * @type {string}
     * @memberof SeasonExtremesDTOV1
     */
    'firstMatch': string;
    /**
     * 
     * @type {string}
     * @memberof SeasonExtremesDTOV1
     */
    'lastMatch': string;
}
/**
 * 
 * @export
 * @interface SetStatsDTOV1
 */
export interface SetStatsDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof SetStatsDTOV1
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof SetStatsDTOV1
     */
    'won': number;
    /**
     * 
     * @type {number}
     * @memberof SetStatsDTOV1
     */
    'lost': number;
    /**
     * 
     * @type {number}
     * @memberof SetStatsDTOV1
     */
    'wonPct': number;
    /**
     * 
     * @type {number}
     * @memberof SetStatsDTOV1
     */
    'lostPct': number;
}
/**
 * 
 * @export
 * @interface StreakDTOV1
 */
export interface StreakDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof StreakDTOV1
     */
    'current': number;
    /**
     * 
     * @type {number}
     * @memberof StreakDTOV1
     */
    'best': number;
    /**
     * 
     * @type {number}
     * @memberof StreakDTOV1
     */
    'worst': number;
}
/**
 * 
 * @export
 * @interface TabtException
 */
export interface TabtException {
    /**
     * 
     * @type {number}
     * @memberof TabtException
     */
    'errorCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof TabtException
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof TabtException
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface TeamDto
 */
export interface TeamDto {
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    'teamId': string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    'team': string;
    /**
     * 
     * @type {number}
     * @memberof TeamDto
     */
    'divisionId': number;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    'divisionName': string;
    /**
     * 
     * @type {string}
     * @memberof TeamDto
     */
    'divisionCategory'?: TeamDtoDivisionCategoryTabt;
    /**
     * 
     * @type {number}
     * @memberof TeamDto
     */
    'matchType': number;
}

export const TeamDtoDivisionCategoryTabt = {
    SenM: 'SEN_M',
    SenW: 'SEN_W',
    YouM: 'YOU_M',
    YouW: 'YOU_W'
} as const;

export type TeamDtoDivisionCategoryTabt = typeof TeamDtoDivisionCategoryTabt[keyof typeof TeamDtoDivisionCategoryTabt];

/**
 * 
 * @export
 * @interface TeamMatchesEntry
 */
export interface TeamMatchesEntry {
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'DivisionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'MatchId': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'WeekName': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'Date'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'Time'?: string;
    /**
     * 
     * @type {number}
     * @memberof TeamMatchesEntry
     */
    'Venue'?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'VenueClub'?: string;
    /**
     * 
     * @type {VenueEntry}
     * @memberof TeamMatchesEntry
     */
    'VenueEntry'?: VenueEntry;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'HomeClub': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'HomeTeam': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'AwayClub': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'AwayTeam': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'Score'?: string;
    /**
     * 
     * @type {number}
     * @memberof TeamMatchesEntry
     */
    'MatchUniqueId'?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'NextWeekName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntry
     */
    'PreviousWeekName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsHomeForfeited': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsAwayForfeited': boolean;
    /**
     * 
     * @type {MatchDetails}
     * @memberof TeamMatchesEntry
     */
    'MatchDetails'?: MatchDetails;
    /**
     * 
     * @type {number}
     * @memberof TeamMatchesEntry
     */
    'DivisionId': number;
    /**
     * 
     * @type {number}
     * @memberof TeamMatchesEntry
     */
    'DivisionCategory': number;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsHomeWithdrawn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsAwayWithdrawn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsValidated': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntry
     */
    'IsLocked': boolean;
}
/**
 * 
 * @export
 * @interface TeamMatchesEntryDTO
 */
export interface TeamMatchesEntryDTO {
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'divisionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'matchId': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'weekName': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'time'?: string;
    /**
     * 
     * @type {number}
     * @memberof TeamMatchesEntryDTO
     */
    'venue'?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'venueClub'?: string;
    /**
     * 
     * @type {VenueEntryDTO}
     * @memberof TeamMatchesEntryDTO
     */
    'venueEntry'?: VenueEntryDTO;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'homeClub': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'homeTeam': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'awayClub': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'awayTeam': string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'score'?: string;
    /**
     * 
     * @type {number}
     * @memberof TeamMatchesEntryDTO
     */
    'matchUniqueId'?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'nextWeekName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'previousWeekName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntryDTO
     */
    'isHomeForfeited': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntryDTO
     */
    'isAwayForfeited': boolean;
    /**
     * 
     * @type {number}
     * @memberof TeamMatchesEntryDTO
     */
    'divisionId': number;
    /**
     * 
     * @type {string}
     * @memberof TeamMatchesEntryDTO
     */
    'divisionCategory'?: TeamMatchesEntryDTODivisionCategoryTabt;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntryDTO
     */
    'isHomeWithdrawn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntryDTO
     */
    'isAwayWithdrawn': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntryDTO
     */
    'isValidated': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamMatchesEntryDTO
     */
    'isLocked': boolean;
    /**
     * 
     * @type {MatchDetailsDTO}
     * @memberof TeamMatchesEntryDTO
     */
    'matchDetails'?: MatchDetailsDTO;
}

export const TeamMatchesEntryDTODivisionCategoryTabt = {
    SenM: 'SEN_M',
    SenW: 'SEN_W',
    YouM: 'YOU_M',
    YouW: 'YOU_W'
} as const;

export type TeamMatchesEntryDTODivisionCategoryTabt = typeof TeamMatchesEntryDTODivisionCategoryTabt[keyof typeof TeamMatchesEntryDTODivisionCategoryTabt];

/**
 * 
 * @export
 * @interface TestOutput
 */
export interface TestOutput {
    /**
     * 
     * @type {string}
     * @memberof TestOutput
     */
    'Timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof TestOutput
     */
    'ApiVersion': string;
    /**
     * 
     * @type {boolean}
     * @memberof TestOutput
     */
    'IsValidAccount': boolean;
    /**
     * 
     * @type {string}
     * @memberof TestOutput
     */
    'Language': TestOutputLanguageTabt;
    /**
     * 
     * @type {string}
     * @memberof TestOutput
     */
    'Database': string;
    /**
     * 
     * @type {string}
     * @memberof TestOutput
     */
    'RequestorIp': string;
    /**
     * 
     * @type {number}
     * @memberof TestOutput
     */
    'ConsumedTicks': number;
    /**
     * 
     * @type {number}
     * @memberof TestOutput
     */
    'CurrentQuota': number;
    /**
     * 
     * @type {number}
     * @memberof TestOutput
     */
    'AllowedQuota': number;
    /**
     * 
     * @type {string}
     * @memberof TestOutput
     */
    'PhpVersion': string;
    /**
     * 
     * @type {string}
     * @memberof TestOutput
     */
    'DbVersion': string;
}

export const TestOutputLanguageTabt = {
    En: 'en',
    Fr: 'fr',
    Nl: 'nl'
} as const;

export type TestOutputLanguageTabt = typeof TestOutputLanguageTabt[keyof typeof TestOutputLanguageTabt];

/**
 * 
 * @export
 * @interface TimeOfDayStatsDTOV1
 */
export interface TimeOfDayStatsDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof TimeOfDayStatsDTOV1
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof TimeOfDayStatsDTOV1
     */
    'victories'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeOfDayStatsDTOV1
     */
    'defeats'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeOfDayStatsDTOV1
     */
    'victoriesPct'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeOfDayStatsDTOV1
     */
    'defeatsPct'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimeOfDayStatsDTOV1
     */
    'timeSlot': TimeOfDayStatsDTOV1TimeSlotTabt;
}

export const TimeOfDayStatsDTOV1TimeSlotTabt = {
    Morning: 'morning',
    Afternoon: 'afternoon',
    Evening: 'evening'
} as const;

export type TimeOfDayStatsDTOV1TimeSlotTabt = typeof TimeOfDayStatsDTOV1TimeSlotTabt[keyof typeof TimeOfDayStatsDTOV1TimeSlotTabt];

/**
 * 
 * @export
 * @interface TournamentEntryDTOV1
 */
export interface TournamentEntryDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof TournamentEntryDTOV1
     */
    'uniqueIndex': number;
    /**
     * 
     * @type {string}
     * @memberof TournamentEntryDTOV1
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TournamentEntryDTOV1
     */
    'level': TournamentEntryDTOV1LevelTabt;
    /**
     * 
     * @type {string}
     * @memberof TournamentEntryDTOV1
     */
    'externalIndex': string;
    /**
     * 
     * @type {string}
     * @memberof TournamentEntryDTOV1
     */
    'dateFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof TournamentEntryDTOV1
     */
    'dateTo'?: string;
    /**
     * 
     * @type {string}
     * @memberof TournamentEntryDTOV1
     */
    'registrationDate'?: string;
    /**
     * 
     * @type {TournamentVenueDTOV1}
     * @memberof TournamentEntryDTOV1
     */
    'venue'?: TournamentVenueDTOV1;
    /**
     * 
     * @type {number}
     * @memberof TournamentEntryDTOV1
     */
    'serieCount'?: number;
    /**
     * 
     * @type {Array<TournamentSerieEntryDTOV1>}
     * @memberof TournamentEntryDTOV1
     */
    'serieEntries'?: Array<TournamentSerieEntryDTOV1>;
}

export const TournamentEntryDTOV1LevelTabt = {
    SuperDivision: 'SUPER_DIVISION',
    National: 'NATIONAL',
    RegionVttl: 'REGION_VTTL',
    Antwerp: 'ANTWERP',
    Limburg: 'LIMBURG',
    OostVlanderen: 'OOST_VLANDEREN',
    WestVlaanderen: 'WEST_VLAANDEREN',
    VlaamsBrabantBr: 'VLAAMS_BRABANT_BR',
    Hainaut: 'HAINAUT',
    Liege: 'LIEGE',
    Luxembourg: 'LUXEMBOURG',
    Namur: 'NAMUR',
    BrusselsBrabantWallon: 'BRUSSELS_BRABANT_WALLON',
    Brussels: 'BRUSSELS',
    Iwb: 'IWB'
} as const;

export type TournamentEntryDTOV1LevelTabt = typeof TournamentEntryDTOV1LevelTabt[keyof typeof TournamentEntryDTOV1LevelTabt];

/**
 * 
 * @export
 * @interface TournamentSerieEntryDTOV1
 */
export interface TournamentSerieEntryDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof TournamentSerieEntryDTOV1
     */
    'uniqueIndex': number;
    /**
     * 
     * @type {string}
     * @memberof TournamentSerieEntryDTOV1
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof TournamentSerieEntryDTOV1
     */
    'resultCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof TournamentSerieEntryDTOV1
     */
    'registrationCount'?: number;
}
/**
 * 
 * @export
 * @interface TournamentVenueDTOV1
 */
export interface TournamentVenueDTOV1 {
    /**
     * 
     * @type {string}
     * @memberof TournamentVenueDTOV1
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TournamentVenueDTOV1
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof TournamentVenueDTOV1
     */
    'town': string;
    /**
     * 
     * @type {string}
     * @memberof TournamentVenueDTOV1
     */
    'lat'?: string;
    /**
     * 
     * @type {string}
     * @memberof TournamentVenueDTOV1
     */
    'lon'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TournamentVenueDTOV1
     */
    'boundingBox'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VenueDto
 */
export interface VenueDto {
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    'street': string;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    'town': string;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueDto
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface VenueEntry
 */
export interface VenueEntry {
    /**
     * 
     * @type {number}
     * @memberof VenueEntry
     */
    'Id'?: number;
    /**
     * 
     * @type {number}
     * @memberof VenueEntry
     */
    'ClubVenue'?: number;
    /**
     * 
     * @type {string}
     * @memberof VenueEntry
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntry
     */
    'Street'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntry
     */
    'Town'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntry
     */
    'Phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntry
     */
    'Comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntry
     */
    'Lat'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntry
     */
    'Lon'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VenueEntry
     */
    'BoundingBox'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VenueEntryDTO
 */
export interface VenueEntryDTO {
    /**
     * 
     * @type {number}
     * @memberof VenueEntryDTO
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof VenueEntryDTO
     */
    'clubVenue'?: number;
    /**
     * 
     * @type {string}
     * @memberof VenueEntryDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntryDTO
     */
    'street'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntryDTO
     */
    'town'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntryDTO
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntryDTO
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntryDTO
     */
    'lat'?: string;
    /**
     * 
     * @type {string}
     * @memberof VenueEntryDTO
     */
    'lon'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VenueEntryDTO
     */
    'boundingBox'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WeeklyNumericPointsV1
 */
export interface WeeklyNumericPointsV1 {
    /**
     * 
     * @type {string}
     * @memberof WeeklyNumericPointsV1
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof WeeklyNumericPointsV1
     */
    'points': number;
    /**
     * 
     * @type {number}
     * @memberof WeeklyNumericPointsV1
     */
    'ranking': number;
    /**
     * 
     * @type {string}
     * @memberof WeeklyNumericPointsV1
     */
    'rankingLetterEstimation'?: string;
}
/**
 * 
 * @export
 * @interface WeeklyNumericRankingHistoryEntryV1
 */
export interface WeeklyNumericRankingHistoryEntryV1 {
    /**
     * The numeric ranking value
     * @type {number}
     * @memberof WeeklyNumericRankingHistoryEntryV1
     */
    'numericRanking': number | null;
    /**
     * Estimated letter ranking based on numeric points
     * @type {string}
     * @memberof WeeklyNumericRankingHistoryEntryV1
     */
    'rankingLetterEstimation': string | null;
    /**
     * Numeric points at this date
     * @type {number}
     * @memberof WeeklyNumericRankingHistoryEntryV1
     */
    'numericPoints': number;
    /**
     * ISO date string of the ranking
     * @type {string}
     * @memberof WeeklyNumericRankingHistoryEntryV1
     */
    'date': string;
}
/**
 * 
 * @export
 * @interface WeeklyPerformanceMetricsDTO
 */
export interface WeeklyPerformanceMetricsDTO {
    /**
     * Weekly Load (0-100) - Measures total effort based on number of sets played and average rally duration
     * @type {number}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'weeklyLoad': number;
    /**
     * Fatigue Resistance (0-100) - Measures ability to maintain performance between first and last set
     * @type {number}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'fatigueResistance': number;
    /**
     * Recovery Score (0-100) - Measures readiness for next week based on performance trend
     * @type {number}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'recoveryScore': number;
    /**
     * Total number of sets played in the week
     * @type {number}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'totalSetsPlayed': number;
    /**
     * Total number of matches played in the week
     * @type {number}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'totalMatchesPlayed': number;
    /**
     * Estimated average rally duration in seconds
     * @type {number}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'averageRallyDuration': number;
    /**
     * Performance drop between first and last set (percentage)
     * @type {number}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'performanceDrop': number;
    /**
     * Indicates if there was a rest day between matches
     * @type {boolean}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'hasRestDay': boolean;
    /**
     * Feedback message about weekly load
     * @type {string}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'weeklyLoadMessage': string;
    /**
     * Feedback message about fatigue resistance
     * @type {string}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'fatigueResistanceMessage': string;
    /**
     * Feedback message about recovery
     * @type {string}
     * @memberof WeeklyPerformanceMetricsDTO
     */
    'recoveryMessage': string;
}
/**
 * 
 * @export
 * @interface WeeklyRankingV1Response
 */
export interface WeeklyRankingV1Response {
    /**
     * Detailed history of matches and points changes
     * @type {Array<NumericRankingDetailsV1>}
     * @memberof WeeklyRankingV1Response
     */
    'perDateHistory': Array<NumericRankingDetailsV1>;
    /**
     * Weekly numeric ranking history
     * @type {Array<WeeklyNumericRankingHistoryEntryV1>}
     * @memberof WeeklyRankingV1Response
     */
    'numericRankingHistory': Array<WeeklyNumericRankingHistoryEntryV1>;
}
/**
 * 
 * @export
 * @interface WinLossSummaryDTOV1
 */
export interface WinLossSummaryDTOV1 {
    /**
     * 
     * @type {number}
     * @memberof WinLossSummaryDTOV1
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof WinLossSummaryDTOV1
     */
    'victories'?: number;
    /**
     * 
     * @type {number}
     * @memberof WinLossSummaryDTOV1
     */
    'defeats'?: number;
    /**
     * 
     * @type {number}
     * @memberof WinLossSummaryDTOV1
     */
    'victoriesPct'?: number;
    /**
     * 
     * @type {number}
     * @memberof WinLossSummaryDTOV1
     */
    'defeatsPct'?: number;
}

/**
 * ClubsApi - axios parameter creator
 * @export
 */
export const ClubsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT'} [clubCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClubs: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, clubCategory?: 'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/clubs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clubCategory !== undefined) {
                localVarQueryParameter['clubCategory'] = clubCategory;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubById: async (clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubIndex' is not null or undefined
            assertParamExists('findClubById', 'clubIndex', clubIndex)
            const localVarPath = `/v1/clubs/{clubIndex}`
                .replace(`{${"clubIndex"}}`, encodeURIComponent(String(clubIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [uniqueIndex] 
         * @param {string} [nameSearch] 
         * @param {boolean} [extendedInformation] 
         * @param {boolean} [rankingPointsInformation] 
         * @param {boolean} [withResults] 
         * @param {boolean} [withOpponentRankingEvaluation] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} [playerCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubMembers: async (clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubIndex' is not null or undefined
            assertParamExists('findClubMembers', 'clubIndex', clubIndex)
            const localVarPath = `/v1/clubs/{clubIndex}/members`
                .replace(`{${"clubIndex"}}`, encodeURIComponent(String(clubIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uniqueIndex !== undefined) {
                localVarQueryParameter['uniqueIndex'] = uniqueIndex;
            }

            if (nameSearch !== undefined) {
                localVarQueryParameter['nameSearch'] = nameSearch;
            }

            if (extendedInformation !== undefined) {
                localVarQueryParameter['extendedInformation'] = extendedInformation;
            }

            if (rankingPointsInformation !== undefined) {
                localVarQueryParameter['rankingPointsInformation'] = rankingPointsInformation;
            }

            if (withResults !== undefined) {
                localVarQueryParameter['withResults'] = withResults;
            }

            if (withOpponentRankingEvaluation !== undefined) {
                localVarQueryParameter['withOpponentRankingEvaluation'] = withOpponentRankingEvaluation;
            }

            if (playerCategory !== undefined) {
                localVarQueryParameter['playerCategory'] = playerCategory;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubTeams: async (clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubIndex' is not null or undefined
            assertParamExists('findClubTeams', 'clubIndex', clubIndex)
            const localVarPath = `/v1/clubs/{clubIndex}/teams`
                .replace(`{${"clubIndex"}}`, encodeURIComponent(String(clubIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} teamId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubTeamsMemberRanking: async (clubIndex: string, teamId: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubIndex' is not null or undefined
            assertParamExists('findClubTeamsMemberRanking', 'clubIndex', clubIndex)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('findClubTeamsMemberRanking', 'teamId', teamId)
            const localVarPath = `/v1/clubs/{clubIndex}/teams/{teamId}/ranking`
                .replace(`{${"clubIndex"}}`, encodeURIComponent(String(clubIndex)))
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMembersRanking: async (clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubIndex' is not null or undefined
            assertParamExists('findMembersRanking', 'clubIndex', clubIndex)
            const localVarPath = `/v1/clubs/{clubIndex}/members/ranking`
                .replace(`{${"clubIndex"}}`, encodeURIComponent(String(clubIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClubsApi - functional programming interface
 * @export
 */
export const ClubsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClubsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT'} [clubCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllClubs(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, clubCategory?: 'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClubDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllClubs(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, clubCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClubById(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClubDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClubById(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [uniqueIndex] 
         * @param {string} [nameSearch] 
         * @param {boolean} [extendedInformation] 
         * @param {boolean} [rankingPointsInformation] 
         * @param {boolean} [withResults] 
         * @param {boolean} [withOpponentRankingEvaluation] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} [playerCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClubMembers(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberEntryDTOV1>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClubMembers(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, uniqueIndex, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, playerCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClubTeams(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClubTeams(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} teamId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClubTeamsMemberRanking(clubIndex: string, teamId: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerMatchStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClubTeamsMemberRanking(clubIndex, teamId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMembersRanking(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerMatchStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMembersRanking(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClubsApi - factory interface
 * @export
 */
export const ClubsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClubsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT'} [clubCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClubs(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, clubCategory?: 'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT', options?: any): AxiosPromise<Array<ClubDto>> {
            return localVarFp.findAllClubs(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, clubCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubById(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<ClubDto> {
            return localVarFp.findClubById(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [uniqueIndex] 
         * @param {string} [nameSearch] 
         * @param {boolean} [extendedInformation] 
         * @param {boolean} [rankingPointsInformation] 
         * @param {boolean} [withResults] 
         * @param {boolean} [withOpponentRankingEvaluation] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} [playerCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubMembers(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', options?: any): AxiosPromise<Array<MemberEntryDTOV1>> {
            return localVarFp.findClubMembers(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, uniqueIndex, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, playerCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubTeams(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: any): AxiosPromise<Array<TeamDto>> {
            return localVarFp.findClubTeams(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} teamId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubTeamsMemberRanking(clubIndex: string, teamId: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: any): AxiosPromise<Array<PlayerMatchStats>> {
            return localVarFp.findClubTeamsMemberRanking(clubIndex, teamId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clubIndex 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [season] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMembersRanking(clubIndex: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, season?: number, options?: any): AxiosPromise<Array<PlayerMatchStats>> {
            return localVarFp.findMembersRanking(clubIndex, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, season, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAllClubs operation in ClubsApi.
 * @export
 * @interface ClubsApiFindAllClubsRequest
 */
export interface ClubsApiFindAllClubsRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindAllClubs
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindAllClubs
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindAllClubs
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindAllClubs
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindAllClubs
     */
    readonly xTabtSeason?: string

    /**
     * 
     * @type {'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT'}
     * @memberof ClubsApiFindAllClubs
     */
    readonly clubCategory?: 'VLAAMS_BRABANT_BR' | 'BRUSSELS_BRABANT_WALLON' | 'ANTWERP' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'LIMBURG' | 'HAINAUT' | 'LUXEMBOURG' | 'LIEGE' | 'NAMUR' | 'VTTL' | 'AFTT' | 'FRBTT'
}

/**
 * Request parameters for findClubById operation in ClubsApi.
 * @export
 * @interface ClubsApiFindClubByIdRequest
 */
export interface ClubsApiFindClubByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ClubsApiFindClubById
     */
    readonly clubIndex: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindClubById
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindClubById
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindClubById
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindClubById
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindClubById
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findClubMembers operation in ClubsApi.
 * @export
 * @interface ClubsApiFindClubMembersRequest
 */
export interface ClubsApiFindClubMembersRequest {
    /**
     * 
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly clubIndex: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindClubMembers
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly xTabtSeason?: string

    /**
     * 
     * @type {number}
     * @memberof ClubsApiFindClubMembers
     */
    readonly uniqueIndex?: number

    /**
     * 
     * @type {string}
     * @memberof ClubsApiFindClubMembers
     */
    readonly nameSearch?: string

    /**
     * 
     * @type {boolean}
     * @memberof ClubsApiFindClubMembers
     */
    readonly extendedInformation?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ClubsApiFindClubMembers
     */
    readonly rankingPointsInformation?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ClubsApiFindClubMembers
     */
    readonly withResults?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ClubsApiFindClubMembers
     */
    readonly withOpponentRankingEvaluation?: boolean

    /**
     * 
     * @type {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'}
     * @memberof ClubsApiFindClubMembers
     */
    readonly playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'
}

/**
 * Request parameters for findClubTeams operation in ClubsApi.
 * @export
 * @interface ClubsApiFindClubTeamsRequest
 */
export interface ClubsApiFindClubTeamsRequest {
    /**
     * 
     * @type {string}
     * @memberof ClubsApiFindClubTeams
     */
    readonly clubIndex: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindClubTeams
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindClubTeams
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindClubTeams
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindClubTeams
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindClubTeams
     */
    readonly xTabtSeason?: string

    /**
     * 
     * @type {number}
     * @memberof ClubsApiFindClubTeams
     */
    readonly season?: number
}

/**
 * Request parameters for findClubTeamsMemberRanking operation in ClubsApi.
 * @export
 * @interface ClubsApiFindClubTeamsMemberRankingRequest
 */
export interface ClubsApiFindClubTeamsMemberRankingRequest {
    /**
     * 
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly clubIndex: string

    /**
     * 
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly teamId: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly xTabtSeason?: string

    /**
     * 
     * @type {number}
     * @memberof ClubsApiFindClubTeamsMemberRanking
     */
    readonly season?: number
}

/**
 * Request parameters for findMembersRanking operation in ClubsApi.
 * @export
 * @interface ClubsApiFindMembersRankingRequest
 */
export interface ClubsApiFindMembersRankingRequest {
    /**
     * 
     * @type {string}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly clubIndex: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly xTabtSeason?: string

    /**
     * 
     * @type {number}
     * @memberof ClubsApiFindMembersRanking
     */
    readonly season?: number
}

/**
 * ClubsApi - object-oriented interface
 * @export
 * @class ClubsApi
 * @extends {BaseAPI}
 */
export class ClubsApi extends BaseAPI {
    /**
     * 
     * @param {ClubsApiFindAllClubsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findAllClubs(requestParameters: ClubsApiFindAllClubsRequest = {}, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findAllClubs(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.clubCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClubsApiFindClubByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findClubById(requestParameters: ClubsApiFindClubByIdRequest, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findClubById(requestParameters.clubIndex, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClubsApiFindClubMembersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findClubMembers(requestParameters: ClubsApiFindClubMembersRequest, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findClubMembers(requestParameters.clubIndex, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.uniqueIndex, requestParameters.nameSearch, requestParameters.extendedInformation, requestParameters.rankingPointsInformation, requestParameters.withResults, requestParameters.withOpponentRankingEvaluation, requestParameters.playerCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClubsApiFindClubTeamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findClubTeams(requestParameters: ClubsApiFindClubTeamsRequest, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findClubTeams(requestParameters.clubIndex, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClubsApiFindClubTeamsMemberRankingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findClubTeamsMemberRanking(requestParameters: ClubsApiFindClubTeamsMemberRankingRequest, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findClubTeamsMemberRanking(requestParameters.clubIndex, requestParameters.teamId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.season, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClubsApiFindMembersRankingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findMembersRanking(requestParameters: ClubsApiFindMembersRankingRequest, options?: AxiosRequestConfig) {
        return ClubsApiFp(this.configuration).findMembersRanking(requestParameters.clubIndex, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.season, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} uniqueIndex 
         * @param {string} [teamId] Team ID to get next match estimation points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberDashboardControllerMemberDashboardV1: async (uniqueIndex: number, teamId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueIndex' is not null or undefined
            assertParamExists('memberDashboardControllerMemberDashboardV1', 'uniqueIndex', uniqueIndex)
            const localVarPath = `/v1/dashboard/member/{uniqueIndex}`
                .replace(`{${"uniqueIndex"}}`, encodeURIComponent(String(uniqueIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (teamId !== undefined) {
                localVarQueryParameter['teamId'] = teamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} uniqueIndex 
         * @param {string} [teamId] Team ID to get next match estimation points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async memberDashboardControllerMemberDashboardV1(uniqueIndex: number, teamId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultiCategoryMemberDashboardDTOV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.memberDashboardControllerMemberDashboardV1(uniqueIndex, teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} uniqueIndex 
         * @param {string} [teamId] Team ID to get next match estimation points
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        memberDashboardControllerMemberDashboardV1(uniqueIndex: number, teamId?: string, options?: any): AxiosPromise<MultiCategoryMemberDashboardDTOV1> {
            return localVarFp.memberDashboardControllerMemberDashboardV1(uniqueIndex, teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for memberDashboardControllerMemberDashboardV1 operation in DashboardsApi.
 * @export
 * @interface DashboardsApiMemberDashboardControllerMemberDashboardV1Request
 */
export interface DashboardsApiMemberDashboardControllerMemberDashboardV1Request {
    /**
     * 
     * @type {number}
     * @memberof DashboardsApiMemberDashboardControllerMemberDashboardV1
     */
    readonly uniqueIndex: number

    /**
     * Team ID to get next match estimation points
     * @type {string}
     * @memberof DashboardsApiMemberDashboardControllerMemberDashboardV1
     */
    readonly teamId?: string
}

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     * 
     * @param {DashboardsApiMemberDashboardControllerMemberDashboardV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public memberDashboardControllerMemberDashboardV1(requestParameters: DashboardsApiMemberDashboardControllerMemberDashboardV1Request, options?: AxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).memberDashboardControllerMemberDashboardV1(requestParameters.uniqueIndex, requestParameters.teamId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAgentControllerGenerateRandomUserAgent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user-agent/random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAgentControllerGenerateRandomUserAgent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAgentControllerGenerateRandomUserAgent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAgentControllerGenerateRandomUserAgent(options?: any): AxiosPromise<void> {
            return localVarFp.userAgentControllerGenerateRandomUserAgent(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public userAgentControllerGenerateRandomUserAgent(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).userAgentControllerGenerateRandomUserAgent(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DivisionsApi - axios parameter creator
 * @export
 */
export const DivisionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List of divisions for a specific season with enum string values.
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'no' | 'yes' | 'short'} [showDivisionName] How to show division names
         * @param {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'} [level] Filter divisions by level category
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'} [divisionCategory] Filter divisions by division category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDivisionsV1: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, showDivisionName?: 'no' | 'yes' | 'short', level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB', divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/divisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (showDivisionName !== undefined) {
                localVarQueryParameter['showDivisionName'] = showDivisionName;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (divisionCategory !== undefined) {
                localVarQueryParameter['divisionCategory'] = divisionCategory;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionByIdV1: async (divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('findDivisionByIdV1', 'divisionId', divisionId)
            const localVarPath = `/v1/divisions/{divisionId}`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {string} [weekName] 
         * @param {string} [yearDateFrom] 
         * @param {string} [yearDateTo] 
         * @param {boolean} [withDetails] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionMatchesV1: async (divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, weekName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('findDivisionMatchesV1', 'divisionId', divisionId)
            const localVarPath = `/v1/divisions/{divisionId}/matches`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (weekName !== undefined) {
                localVarQueryParameter['weekName'] = weekName;
            }

            if (yearDateFrom !== undefined) {
                localVarQueryParameter['yearDateFrom'] = yearDateFrom;
            }

            if (yearDateTo !== undefined) {
                localVarQueryParameter['yearDateTo'] = yearDateTo;
            }

            if (withDetails !== undefined) {
                localVarQueryParameter['withDetails'] = withDetails;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionMembersV1: async (divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('findDivisionMembersV1', 'divisionId', divisionId)
            const localVarPath = `/v1/divisions/{divisionId}/members/ranking`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [rankingSystem] 
         * @param {string} [weekName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionRankingV1: async (divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, rankingSystem?: number, weekName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'divisionId' is not null or undefined
            assertParamExists('findDivisionRankingV1', 'divisionId', divisionId)
            const localVarPath = `/v1/divisions/{divisionId}/ranking`
                .replace(`{${"divisionId"}}`, encodeURIComponent(String(divisionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (rankingSystem !== undefined) {
                localVarQueryParameter['rankingSystem'] = rankingSystem;
            }

            if (weekName !== undefined) {
                localVarQueryParameter['weekName'] = weekName;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DivisionsApi - functional programming interface
 * @export
 */
export const DivisionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DivisionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List of divisions for a specific season with enum string values.
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'no' | 'yes' | 'short'} [showDivisionName] How to show division names
         * @param {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'} [level] Filter divisions by level category
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'} [divisionCategory] Filter divisions by division category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDivisionsV1(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, showDivisionName?: 'no' | 'yes' | 'short', level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB', divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DivisionEntryDtoV1>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDivisionsV1(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, showDivisionName, level, divisionCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDivisionByIdV1(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DivisionEntryDtoV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDivisionByIdV1(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {string} [weekName] 
         * @param {string} [yearDateFrom] 
         * @param {string} [yearDateTo] 
         * @param {boolean} [withDetails] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDivisionMatchesV1(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, weekName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamMatchesEntryDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDivisionMatchesV1(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, weekName, yearDateFrom, yearDateTo, withDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDivisionMembersV1(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerMatchStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDivisionMembersV1(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [rankingSystem] 
         * @param {string} [weekName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDivisionRankingV1(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, rankingSystem?: number, weekName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankingEntryDtoV1>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDivisionRankingV1(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, rankingSystem, weekName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DivisionsApi - factory interface
 * @export
 */
export const DivisionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DivisionsApiFp(configuration)
    return {
        /**
         * 
         * @summary List of divisions for a specific season with enum string values.
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {'no' | 'yes' | 'short'} [showDivisionName] How to show division names
         * @param {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'} [level] Filter divisions by level category
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'} [divisionCategory] Filter divisions by division category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDivisionsV1(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, showDivisionName?: 'no' | 'yes' | 'short', level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB', divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W', options?: any): AxiosPromise<Array<DivisionEntryDtoV1>> {
            return localVarFp.findAllDivisionsV1(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, showDivisionName, level, divisionCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionByIdV1(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<DivisionEntryDtoV1> {
            return localVarFp.findDivisionByIdV1(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {string} [weekName] 
         * @param {string} [yearDateFrom] 
         * @param {string} [yearDateTo] 
         * @param {boolean} [withDetails] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionMatchesV1(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, weekName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, options?: any): AxiosPromise<Array<TeamMatchesEntryDTO>> {
            return localVarFp.findDivisionMatchesV1(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, weekName, yearDateFrom, yearDateTo, withDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionMembersV1(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<Array<PlayerMatchStats>> {
            return localVarFp.findDivisionMembersV1(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} divisionId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [rankingSystem] 
         * @param {string} [weekName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDivisionRankingV1(divisionId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, rankingSystem?: number, weekName?: string, options?: any): AxiosPromise<Array<RankingEntryDtoV1>> {
            return localVarFp.findDivisionRankingV1(divisionId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, rankingSystem, weekName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAllDivisionsV1 operation in DivisionsApi.
 * @export
 * @interface DivisionsApiFindAllDivisionsV1Request
 */
export interface DivisionsApiFindAllDivisionsV1Request {
    /**
     * Account to do a request
     * @type {string}
     * @memberof DivisionsApiFindAllDivisionsV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof DivisionsApiFindAllDivisionsV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof DivisionsApiFindAllDivisionsV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof DivisionsApiFindAllDivisionsV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof DivisionsApiFindAllDivisionsV1
     */
    readonly xTabtSeason?: string

    /**
     * How to show division names
     * @type {'no' | 'yes' | 'short'}
     * @memberof DivisionsApiFindAllDivisionsV1
     */
    readonly showDivisionName?: 'no' | 'yes' | 'short'

    /**
     * Filter divisions by level category
     * @type {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'}
     * @memberof DivisionsApiFindAllDivisionsV1
     */
    readonly level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'

    /**
     * Filter divisions by division category
     * @type {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'}
     * @memberof DivisionsApiFindAllDivisionsV1
     */
    readonly divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'
}

/**
 * Request parameters for findDivisionByIdV1 operation in DivisionsApi.
 * @export
 * @interface DivisionsApiFindDivisionByIdV1Request
 */
export interface DivisionsApiFindDivisionByIdV1Request {
    /**
     * 
     * @type {number}
     * @memberof DivisionsApiFindDivisionByIdV1
     */
    readonly divisionId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof DivisionsApiFindDivisionByIdV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof DivisionsApiFindDivisionByIdV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof DivisionsApiFindDivisionByIdV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof DivisionsApiFindDivisionByIdV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof DivisionsApiFindDivisionByIdV1
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findDivisionMatchesV1 operation in DivisionsApi.
 * @export
 * @interface DivisionsApiFindDivisionMatchesV1Request
 */
export interface DivisionsApiFindDivisionMatchesV1Request {
    /**
     * 
     * @type {number}
     * @memberof DivisionsApiFindDivisionMatchesV1
     */
    readonly divisionId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatchesV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatchesV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatchesV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof DivisionsApiFindDivisionMatchesV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatchesV1
     */
    readonly xTabtSeason?: string

    /**
     * 
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatchesV1
     */
    readonly weekName?: string

    /**
     * 
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatchesV1
     */
    readonly yearDateFrom?: string

    /**
     * 
     * @type {string}
     * @memberof DivisionsApiFindDivisionMatchesV1
     */
    readonly yearDateTo?: string

    /**
     * 
     * @type {boolean}
     * @memberof DivisionsApiFindDivisionMatchesV1
     */
    readonly withDetails?: boolean
}

/**
 * Request parameters for findDivisionMembersV1 operation in DivisionsApi.
 * @export
 * @interface DivisionsApiFindDivisionMembersV1Request
 */
export interface DivisionsApiFindDivisionMembersV1Request {
    /**
     * 
     * @type {number}
     * @memberof DivisionsApiFindDivisionMembersV1
     */
    readonly divisionId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof DivisionsApiFindDivisionMembersV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof DivisionsApiFindDivisionMembersV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof DivisionsApiFindDivisionMembersV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof DivisionsApiFindDivisionMembersV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof DivisionsApiFindDivisionMembersV1
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findDivisionRankingV1 operation in DivisionsApi.
 * @export
 * @interface DivisionsApiFindDivisionRankingV1Request
 */
export interface DivisionsApiFindDivisionRankingV1Request {
    /**
     * 
     * @type {number}
     * @memberof DivisionsApiFindDivisionRankingV1
     */
    readonly divisionId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof DivisionsApiFindDivisionRankingV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof DivisionsApiFindDivisionRankingV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof DivisionsApiFindDivisionRankingV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof DivisionsApiFindDivisionRankingV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof DivisionsApiFindDivisionRankingV1
     */
    readonly xTabtSeason?: string

    /**
     * 
     * @type {number}
     * @memberof DivisionsApiFindDivisionRankingV1
     */
    readonly rankingSystem?: number

    /**
     * 
     * @type {string}
     * @memberof DivisionsApiFindDivisionRankingV1
     */
    readonly weekName?: string
}

/**
 * DivisionsApi - object-oriented interface
 * @export
 * @class DivisionsApi
 * @extends {BaseAPI}
 */
export class DivisionsApi extends BaseAPI {
    /**
     * 
     * @summary List of divisions for a specific season with enum string values.
     * @param {DivisionsApiFindAllDivisionsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public findAllDivisionsV1(requestParameters: DivisionsApiFindAllDivisionsV1Request = {}, options?: AxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).findAllDivisionsV1(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.showDivisionName, requestParameters.level, requestParameters.divisionCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DivisionsApiFindDivisionByIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public findDivisionByIdV1(requestParameters: DivisionsApiFindDivisionByIdV1Request, options?: AxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).findDivisionByIdV1(requestParameters.divisionId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DivisionsApiFindDivisionMatchesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public findDivisionMatchesV1(requestParameters: DivisionsApiFindDivisionMatchesV1Request, options?: AxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).findDivisionMatchesV1(requestParameters.divisionId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.weekName, requestParameters.yearDateFrom, requestParameters.yearDateTo, requestParameters.withDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DivisionsApiFindDivisionMembersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public findDivisionMembersV1(requestParameters: DivisionsApiFindDivisionMembersV1Request, options?: AxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).findDivisionMembersV1(requestParameters.divisionId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DivisionsApiFindDivisionRankingV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DivisionsApi
     */
    public findDivisionRankingV1(requestParameters: DivisionsApiFindDivisionRankingV1Request, options?: AxiosRequestConfig) {
        return DivisionsApiFp(this.configuration).findDivisionRankingV1(requestParameters.divisionId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.rankingSystem, requestParameters.weekName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Head2HeadApi - axios parameter creator
 * @export
 */
export const Head2HeadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} playerUniqueIndex 
         * @param {number} opponentUniqueIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findHead2HeadMatches: async (playerUniqueIndex: number, opponentUniqueIndex: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerUniqueIndex' is not null or undefined
            assertParamExists('findHead2HeadMatches', 'playerUniqueIndex', playerUniqueIndex)
            // verify required parameter 'opponentUniqueIndex' is not null or undefined
            assertParamExists('findHead2HeadMatches', 'opponentUniqueIndex', opponentUniqueIndex)
            const localVarPath = `/v1/head2head/{playerUniqueIndex}/{opponentUniqueIndex}`
                .replace(`{${"playerUniqueIndex"}}`, encodeURIComponent(String(playerUniqueIndex)))
                .replace(`{${"opponentUniqueIndex"}}`, encodeURIComponent(String(opponentUniqueIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Head2HeadApi - functional programming interface
 * @export
 */
export const Head2HeadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Head2HeadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} playerUniqueIndex 
         * @param {number} opponentUniqueIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findHead2HeadMatches(playerUniqueIndex: number, opponentUniqueIndex: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Head2HeadData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findHead2HeadMatches(playerUniqueIndex, opponentUniqueIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Head2HeadApi - factory interface
 * @export
 */
export const Head2HeadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Head2HeadApiFp(configuration)
    return {
        /**
         * 
         * @param {number} playerUniqueIndex 
         * @param {number} opponentUniqueIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findHead2HeadMatches(playerUniqueIndex: number, opponentUniqueIndex: number, options?: any): AxiosPromise<Head2HeadData> {
            return localVarFp.findHead2HeadMatches(playerUniqueIndex, opponentUniqueIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findHead2HeadMatches operation in Head2HeadApi.
 * @export
 * @interface Head2HeadApiFindHead2HeadMatchesRequest
 */
export interface Head2HeadApiFindHead2HeadMatchesRequest {
    /**
     * 
     * @type {number}
     * @memberof Head2HeadApiFindHead2HeadMatches
     */
    readonly playerUniqueIndex: number

    /**
     * 
     * @type {number}
     * @memberof Head2HeadApiFindHead2HeadMatches
     */
    readonly opponentUniqueIndex: number
}

/**
 * Head2HeadApi - object-oriented interface
 * @export
 * @class Head2HeadApi
 * @extends {BaseAPI}
 */
export class Head2HeadApi extends BaseAPI {
    /**
     * 
     * @param {Head2HeadApiFindHead2HeadMatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Head2HeadApi
     */
    public findHead2HeadMatches(requestParameters: Head2HeadApiFindHead2HeadMatchesRequest, options?: AxiosRequestConfig) {
        return Head2HeadApiFp(this.configuration).findHead2HeadMatches(requestParameters.playerUniqueIndex, requestParameters.opponentUniqueIndex, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        context: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRequest: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkHealth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkHealth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async context(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.context(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testRequest(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testRequest(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkHealth(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.checkHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        context(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<void> {
            return localVarFp.context(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRequest(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<TestOutput> {
            return localVarFp.testRequest(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for context operation in HealthApi.
 * @export
 * @interface HealthApiContextRequest
 */
export interface HealthApiContextRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof HealthApiContext
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof HealthApiContext
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof HealthApiContext
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof HealthApiContext
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof HealthApiContext
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for testRequest operation in HealthApi.
 * @export
 * @interface HealthApiTestRequestRequest
 */
export interface HealthApiTestRequestRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof HealthApiTestRequest
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof HealthApiTestRequest
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof HealthApiTestRequest
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof HealthApiTestRequest
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof HealthApiTestRequest
     */
    readonly xTabtSeason?: string
}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public checkHealth(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).checkHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HealthApiContextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public context(requestParameters: HealthApiContextRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).context(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HealthApiTestRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public testRequest(requestParameters: HealthApiTestRequestRequest = {}, options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).testRequest(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InternalIdentifiersApi - axios parameter creator
 * @export
 */
export const InternalIdentifiersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} clubUniqueIndex 
         * @param {number} playerUniqueIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalIds: async (clubUniqueIndex: string, playerUniqueIndex: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubUniqueIndex' is not null or undefined
            assertParamExists('getInternalIds', 'clubUniqueIndex', clubUniqueIndex)
            // verify required parameter 'playerUniqueIndex' is not null or undefined
            assertParamExists('getInternalIds', 'playerUniqueIndex', playerUniqueIndex)
            const localVarPath = `/v1/internal-identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clubUniqueIndex !== undefined) {
                localVarQueryParameter['clubUniqueIndex'] = clubUniqueIndex;
            }

            if (playerUniqueIndex !== undefined) {
                localVarQueryParameter['playerUniqueIndex'] = playerUniqueIndex;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} clubUniqueIndex 
         * @param {number} playerUniqueIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisterLink: async (clubUniqueIndex: string, playerUniqueIndex: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clubUniqueIndex' is not null or undefined
            assertParamExists('getRegisterLink', 'clubUniqueIndex', clubUniqueIndex)
            // verify required parameter 'playerUniqueIndex' is not null or undefined
            assertParamExists('getRegisterLink', 'playerUniqueIndex', playerUniqueIndex)
            const localVarPath = `/v1/internal-identifiers/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clubUniqueIndex !== undefined) {
                localVarQueryParameter['clubUniqueIndex'] = clubUniqueIndex;
            }

            if (playerUniqueIndex !== undefined) {
                localVarQueryParameter['playerUniqueIndex'] = playerUniqueIndex;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalIdentifiersApi - functional programming interface
 * @export
 */
export const InternalIdentifiersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalIdentifiersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} clubUniqueIndex 
         * @param {number} playerUniqueIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInternalIds(clubUniqueIndex: string, playerUniqueIndex: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalIdentifiersDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInternalIds(clubUniqueIndex, playerUniqueIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} clubUniqueIndex 
         * @param {number} playerUniqueIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegisterLink(clubUniqueIndex: string, playerUniqueIndex: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectLinkDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegisterLink(clubUniqueIndex, playerUniqueIndex, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InternalIdentifiersApi - factory interface
 * @export
 */
export const InternalIdentifiersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalIdentifiersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} clubUniqueIndex 
         * @param {number} playerUniqueIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalIds(clubUniqueIndex: string, playerUniqueIndex: number, options?: any): AxiosPromise<InternalIdentifiersDTO> {
            return localVarFp.getInternalIds(clubUniqueIndex, playerUniqueIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} clubUniqueIndex 
         * @param {number} playerUniqueIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegisterLink(clubUniqueIndex: string, playerUniqueIndex: number, options?: any): AxiosPromise<RedirectLinkDTO> {
            return localVarFp.getRegisterLink(clubUniqueIndex, playerUniqueIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getInternalIds operation in InternalIdentifiersApi.
 * @export
 * @interface InternalIdentifiersApiGetInternalIdsRequest
 */
export interface InternalIdentifiersApiGetInternalIdsRequest {
    /**
     * 
     * @type {string}
     * @memberof InternalIdentifiersApiGetInternalIds
     */
    readonly clubUniqueIndex: string

    /**
     * 
     * @type {number}
     * @memberof InternalIdentifiersApiGetInternalIds
     */
    readonly playerUniqueIndex: number
}

/**
 * Request parameters for getRegisterLink operation in InternalIdentifiersApi.
 * @export
 * @interface InternalIdentifiersApiGetRegisterLinkRequest
 */
export interface InternalIdentifiersApiGetRegisterLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof InternalIdentifiersApiGetRegisterLink
     */
    readonly clubUniqueIndex: string

    /**
     * 
     * @type {number}
     * @memberof InternalIdentifiersApiGetRegisterLink
     */
    readonly playerUniqueIndex: number
}

/**
 * InternalIdentifiersApi - object-oriented interface
 * @export
 * @class InternalIdentifiersApi
 * @extends {BaseAPI}
 */
export class InternalIdentifiersApi extends BaseAPI {
    /**
     * 
     * @param {InternalIdentifiersApiGetInternalIdsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalIdentifiersApi
     */
    public getInternalIds(requestParameters: InternalIdentifiersApiGetInternalIdsRequest, options?: AxiosRequestConfig) {
        return InternalIdentifiersApiFp(this.configuration).getInternalIds(requestParameters.clubUniqueIndex, requestParameters.playerUniqueIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InternalIdentifiersApiGetRegisterLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalIdentifiersApi
     */
    public getRegisterLink(requestParameters: InternalIdentifiersApiGetRegisterLinkRequest, options?: AxiosRequestConfig) {
        return InternalIdentifiersApiFp(this.configuration).getRegisterLink(requestParameters.clubUniqueIndex, requestParameters.playerUniqueIndex, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MatchesApi - axios parameter creator
 * @export
 */
export const MatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchSystems: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId] 
         * @param {string} [club] 
         * @param {string} [team] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'} [divisionCategory] 
         * @param {number} [weekName] 
         * @param {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'} [level] 
         * @param {string} [showDivisionName] 
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails] 
         * @param {string} [matchId] 
         * @param {number} [matchUniqueId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatches: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W', weekName?: number, level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, matchUniqueId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (divisionId !== undefined) {
                localVarQueryParameter['divisionId'] = divisionId;
            }

            if (club !== undefined) {
                localVarQueryParameter['club'] = club;
            }

            if (team !== undefined) {
                localVarQueryParameter['team'] = team;
            }

            if (divisionCategory !== undefined) {
                localVarQueryParameter['divisionCategory'] = divisionCategory;
            }

            if (weekName !== undefined) {
                localVarQueryParameter['weekName'] = weekName;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (showDivisionName !== undefined) {
                localVarQueryParameter['showDivisionName'] = showDivisionName;
            }

            if (yearDateFrom !== undefined) {
                localVarQueryParameter['yearDateFrom'] = yearDateFrom;
            }

            if (yearDateTo !== undefined) {
                localVarQueryParameter['yearDateTo'] = yearDateTo;
            }

            if (withDetails !== undefined) {
                localVarQueryParameter['withDetails'] = withDetails;
            }

            if (matchId !== undefined) {
                localVarQueryParameter['matchId'] = matchId;
            }

            if (matchUniqueId !== undefined) {
                localVarQueryParameter['matchUniqueId'] = matchUniqueId;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} matchUniqueId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId] 
         * @param {string} [club] 
         * @param {string} [team] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'} [divisionCategory] 
         * @param {number} [weekName] 
         * @param {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'} [level] 
         * @param {string} [showDivisionName] 
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails] 
         * @param {string} [matchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMatchById: async (matchUniqueId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W', weekName?: number, level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchUniqueId' is not null or undefined
            assertParamExists('findMatchById', 'matchUniqueId', matchUniqueId)
            const localVarPath = `/v1/matches/{matchUniqueId}`
                .replace(`{${"matchUniqueId"}}`, encodeURIComponent(String(matchUniqueId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (divisionId !== undefined) {
                localVarQueryParameter['divisionId'] = divisionId;
            }

            if (club !== undefined) {
                localVarQueryParameter['club'] = club;
            }

            if (team !== undefined) {
                localVarQueryParameter['team'] = team;
            }

            if (divisionCategory !== undefined) {
                localVarQueryParameter['divisionCategory'] = divisionCategory;
            }

            if (weekName !== undefined) {
                localVarQueryParameter['weekName'] = weekName;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (showDivisionName !== undefined) {
                localVarQueryParameter['showDivisionName'] = showDivisionName;
            }

            if (yearDateFrom !== undefined) {
                localVarQueryParameter['yearDateFrom'] = yearDateFrom;
            }

            if (yearDateTo !== undefined) {
                localVarQueryParameter['yearDateTo'] = yearDateTo;
            }

            if (withDetails !== undefined) {
                localVarQueryParameter['withDetails'] = withDetails;
            }

            if (matchId !== undefined) {
                localVarQueryParameter['matchId'] = matchId;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} matchSystemId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMatchSystemById: async (matchSystemId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchSystemId' is not null or undefined
            assertParamExists('findMatchSystemById', 'matchSystemId', matchSystemId)
            const localVarPath = `/v1/matches/systems/{matchSystemId}`
                .replace(`{${"matchSystemId"}}`, encodeURIComponent(String(matchSystemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get weekly performance metrics for a player including load score, fatigue resistance, and recovery score
         * @param {number} playerUniqueIndex 
         * @param {string} weekName 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeeklyPerformanceMetrics: async (playerUniqueIndex: number, weekName: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerUniqueIndex' is not null or undefined
            assertParamExists('getWeeklyPerformanceMetrics', 'playerUniqueIndex', playerUniqueIndex)
            // verify required parameter 'weekName' is not null or undefined
            assertParamExists('getWeeklyPerformanceMetrics', 'weekName', weekName)
            const localVarPath = `/v1/matches/player/{playerUniqueIndex}/performance`
                .replace(`{${"playerUniqueIndex"}}`, encodeURIComponent(String(playerUniqueIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (weekName !== undefined) {
                localVarQueryParameter['weekName'] = weekName;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchesApi - functional programming interface
 * @export
 */
export const MatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllMatchSystems(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MatchSystemEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllMatchSystems(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId] 
         * @param {string} [club] 
         * @param {string} [team] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'} [divisionCategory] 
         * @param {number} [weekName] 
         * @param {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'} [level] 
         * @param {string} [showDivisionName] 
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails] 
         * @param {string} [matchId] 
         * @param {number} [matchUniqueId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllMatches(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W', weekName?: number, level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, matchUniqueId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamMatchesEntryDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllMatches(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, divisionId, club, team, divisionCategory, weekName, level, showDivisionName, yearDateFrom, yearDateTo, withDetails, matchId, matchUniqueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} matchUniqueId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId] 
         * @param {string} [club] 
         * @param {string} [team] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'} [divisionCategory] 
         * @param {number} [weekName] 
         * @param {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'} [level] 
         * @param {string} [showDivisionName] 
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails] 
         * @param {string} [matchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMatchById(matchUniqueId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W', weekName?: number, level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamMatchesEntryDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMatchById(matchUniqueId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, divisionId, club, team, divisionCategory, weekName, level, showDivisionName, yearDateFrom, yearDateTo, withDetails, matchId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} matchSystemId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMatchSystemById(matchSystemId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchSystemEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMatchSystemById(matchSystemId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get weekly performance metrics for a player including load score, fatigue resistance, and recovery score
         * @param {number} playerUniqueIndex 
         * @param {string} weekName 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWeeklyPerformanceMetrics(playerUniqueIndex: number, weekName: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WeeklyPerformanceMetricsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWeeklyPerformanceMetrics(playerUniqueIndex, weekName, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchesApi - factory interface
 * @export
 */
export const MatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatchSystems(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<Array<MatchSystemEntry>> {
            return localVarFp.findAllMatchSystems(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId] 
         * @param {string} [club] 
         * @param {string} [team] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'} [divisionCategory] 
         * @param {number} [weekName] 
         * @param {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'} [level] 
         * @param {string} [showDivisionName] 
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails] 
         * @param {string} [matchId] 
         * @param {number} [matchUniqueId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMatches(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W', weekName?: number, level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, matchUniqueId?: number, options?: any): AxiosPromise<Array<TeamMatchesEntryDTO>> {
            return localVarFp.findAllMatches(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, divisionId, club, team, divisionCategory, weekName, level, showDivisionName, yearDateFrom, yearDateTo, withDetails, matchId, matchUniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} matchUniqueId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {number} [divisionId] 
         * @param {string} [club] 
         * @param {string} [team] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'} [divisionCategory] 
         * @param {number} [weekName] 
         * @param {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'} [level] 
         * @param {string} [showDivisionName] 
         * @param {string} [yearDateFrom] YYYY-MM-DD
         * @param {string} [yearDateTo] YYYY-MM-DD
         * @param {boolean} [withDetails] 
         * @param {string} [matchId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMatchById(matchUniqueId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, divisionId?: number, club?: string, team?: string, divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W', weekName?: number, level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB', showDivisionName?: string, yearDateFrom?: string, yearDateTo?: string, withDetails?: boolean, matchId?: string, options?: any): AxiosPromise<TeamMatchesEntryDTO> {
            return localVarFp.findMatchById(matchUniqueId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, divisionId, club, team, divisionCategory, weekName, level, showDivisionName, yearDateFrom, yearDateTo, withDetails, matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} matchSystemId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMatchSystemById(matchSystemId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<MatchSystemEntry> {
            return localVarFp.findMatchSystemById(matchSystemId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * Get weekly performance metrics for a player including load score, fatigue resistance, and recovery score
         * @param {number} playerUniqueIndex 
         * @param {string} weekName 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWeeklyPerformanceMetrics(playerUniqueIndex: number, weekName: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<WeeklyPerformanceMetricsDTO> {
            return localVarFp.getWeeklyPerformanceMetrics(playerUniqueIndex, weekName, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAllMatchSystems operation in MatchesApi.
 * @export
 * @interface MatchesApiFindAllMatchSystemsRequest
 */
export interface MatchesApiFindAllMatchSystemsRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof MatchesApiFindAllMatchSystems
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MatchesApiFindAllMatchSystems
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MatchesApiFindAllMatchSystems
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MatchesApiFindAllMatchSystems
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MatchesApiFindAllMatchSystems
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findAllMatches operation in MatchesApi.
 * @export
 * @interface MatchesApiFindAllMatchesRequest
 */
export interface MatchesApiFindAllMatchesRequest {
    /**
     * Account to do a request
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MatchesApiFindAllMatches
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly xTabtSeason?: string

    /**
     * 
     * @type {number}
     * @memberof MatchesApiFindAllMatches
     */
    readonly divisionId?: number

    /**
     * 
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly club?: string

    /**
     * 
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly team?: string

    /**
     * 
     * @type {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'}
     * @memberof MatchesApiFindAllMatches
     */
    readonly divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'

    /**
     * 
     * @type {number}
     * @memberof MatchesApiFindAllMatches
     */
    readonly weekName?: number

    /**
     * 
     * @type {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'}
     * @memberof MatchesApiFindAllMatches
     */
    readonly level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'

    /**
     * 
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly showDivisionName?: string

    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly yearDateFrom?: string

    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly yearDateTo?: string

    /**
     * 
     * @type {boolean}
     * @memberof MatchesApiFindAllMatches
     */
    readonly withDetails?: boolean

    /**
     * 
     * @type {string}
     * @memberof MatchesApiFindAllMatches
     */
    readonly matchId?: string

    /**
     * 
     * @type {number}
     * @memberof MatchesApiFindAllMatches
     */
    readonly matchUniqueId?: number
}

/**
 * Request parameters for findMatchById operation in MatchesApi.
 * @export
 * @interface MatchesApiFindMatchByIdRequest
 */
export interface MatchesApiFindMatchByIdRequest {
    /**
     * 
     * @type {number}
     * @memberof MatchesApiFindMatchById
     */
    readonly matchUniqueId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MatchesApiFindMatchById
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly xTabtSeason?: string

    /**
     * 
     * @type {number}
     * @memberof MatchesApiFindMatchById
     */
    readonly divisionId?: number

    /**
     * 
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly club?: string

    /**
     * 
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly team?: string

    /**
     * 
     * @type {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'}
     * @memberof MatchesApiFindMatchById
     */
    readonly divisionCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W'

    /**
     * 
     * @type {number}
     * @memberof MatchesApiFindMatchById
     */
    readonly weekName?: number

    /**
     * 
     * @type {'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'}
     * @memberof MatchesApiFindMatchById
     */
    readonly level?: 'SUPER_DIVISION' | 'NATIONAL' | 'REGION_VTTL' | 'ANTWERP' | 'LIMBURG' | 'OOST_VLANDEREN' | 'WEST_VLAANDEREN' | 'VLAAMS_BRABANT_BR' | 'HAINAUT' | 'LIEGE' | 'LUXEMBOURG' | 'NAMUR' | 'BRUSSELS_BRABANT_WALLON' | 'BRUSSELS' | 'IWB'

    /**
     * 
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly showDivisionName?: string

    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly yearDateFrom?: string

    /**
     * YYYY-MM-DD
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly yearDateTo?: string

    /**
     * 
     * @type {boolean}
     * @memberof MatchesApiFindMatchById
     */
    readonly withDetails?: boolean

    /**
     * 
     * @type {string}
     * @memberof MatchesApiFindMatchById
     */
    readonly matchId?: string
}

/**
 * Request parameters for findMatchSystemById operation in MatchesApi.
 * @export
 * @interface MatchesApiFindMatchSystemByIdRequest
 */
export interface MatchesApiFindMatchSystemByIdRequest {
    /**
     * 
     * @type {number}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly matchSystemId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MatchesApiFindMatchSystemById
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for getWeeklyPerformanceMetrics operation in MatchesApi.
 * @export
 * @interface MatchesApiGetWeeklyPerformanceMetricsRequest
 */
export interface MatchesApiGetWeeklyPerformanceMetricsRequest {
    /**
     * 
     * @type {number}
     * @memberof MatchesApiGetWeeklyPerformanceMetrics
     */
    readonly playerUniqueIndex: number

    /**
     * 
     * @type {string}
     * @memberof MatchesApiGetWeeklyPerformanceMetrics
     */
    readonly weekName: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof MatchesApiGetWeeklyPerformanceMetrics
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MatchesApiGetWeeklyPerformanceMetrics
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MatchesApiGetWeeklyPerformanceMetrics
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MatchesApiGetWeeklyPerformanceMetrics
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MatchesApiGetWeeklyPerformanceMetrics
     */
    readonly xTabtSeason?: string
}

/**
 * MatchesApi - object-oriented interface
 * @export
 * @class MatchesApi
 * @extends {BaseAPI}
 */
export class MatchesApi extends BaseAPI {
    /**
     * 
     * @param {MatchesApiFindAllMatchSystemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public findAllMatchSystems(requestParameters: MatchesApiFindAllMatchSystemsRequest = {}, options?: AxiosRequestConfig) {
        return MatchesApiFp(this.configuration).findAllMatchSystems(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MatchesApiFindAllMatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public findAllMatches(requestParameters: MatchesApiFindAllMatchesRequest = {}, options?: AxiosRequestConfig) {
        return MatchesApiFp(this.configuration).findAllMatches(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.divisionId, requestParameters.club, requestParameters.team, requestParameters.divisionCategory, requestParameters.weekName, requestParameters.level, requestParameters.showDivisionName, requestParameters.yearDateFrom, requestParameters.yearDateTo, requestParameters.withDetails, requestParameters.matchId, requestParameters.matchUniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MatchesApiFindMatchByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public findMatchById(requestParameters: MatchesApiFindMatchByIdRequest, options?: AxiosRequestConfig) {
        return MatchesApiFp(this.configuration).findMatchById(requestParameters.matchUniqueId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.divisionId, requestParameters.club, requestParameters.team, requestParameters.divisionCategory, requestParameters.weekName, requestParameters.level, requestParameters.showDivisionName, requestParameters.yearDateFrom, requestParameters.yearDateTo, requestParameters.withDetails, requestParameters.matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MatchesApiFindMatchSystemByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public findMatchSystemById(requestParameters: MatchesApiFindMatchSystemByIdRequest, options?: AxiosRequestConfig) {
        return MatchesApiFp(this.configuration).findMatchSystemById(requestParameters.matchSystemId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get weekly performance metrics for a player including load score, fatigue resistance, and recovery score
     * @param {MatchesApiGetWeeklyPerformanceMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public getWeeklyPerformanceMetrics(requestParameters: MatchesApiGetWeeklyPerformanceMetricsRequest, options?: AxiosRequestConfig) {
        return MatchesApiFp(this.configuration).getWeeklyPerformanceMetrics(requestParameters.playerUniqueIndex, requestParameters.weekName, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [club] 
         * @param {number} [uniqueIndex] 
         * @param {string} [nameSearch] 
         * @param {boolean} [extendedInformation] 
         * @param {boolean} [rankingPointsInformation] 
         * @param {boolean} [withResults] 
         * @param {boolean} [withOpponentRankingEvaluation] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} [playerCategory] 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMembersV1: async (club?: string, uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (club !== undefined) {
                localVarQueryParameter['club'] = club;
            }

            if (uniqueIndex !== undefined) {
                localVarQueryParameter['uniqueIndex'] = uniqueIndex;
            }

            if (nameSearch !== undefined) {
                localVarQueryParameter['nameSearch'] = nameSearch;
            }

            if (extendedInformation !== undefined) {
                localVarQueryParameter['extendedInformation'] = extendedInformation;
            }

            if (rankingPointsInformation !== undefined) {
                localVarQueryParameter['rankingPointsInformation'] = rankingPointsInformation;
            }

            if (withResults !== undefined) {
                localVarQueryParameter['withResults'] = withResults;
            }

            if (withOpponentRankingEvaluation !== undefined) {
                localVarQueryParameter['withOpponentRankingEvaluation'] = withOpponentRankingEvaluation;
            }

            if (playerCategory !== undefined) {
                localVarQueryParameter['playerCategory'] = playerCategory;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} uniqueIndex 
         * @param {string} [club] 
         * @param {string} [nameSearch] 
         * @param {boolean} [extendedInformation] 
         * @param {boolean} [rankingPointsInformation] 
         * @param {boolean} [withResults] 
         * @param {boolean} [withOpponentRankingEvaluation] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} [playerCategory] 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberByIdV1: async (uniqueIndex: number, club?: string, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueIndex' is not null or undefined
            assertParamExists('findMemberByIdV1', 'uniqueIndex', uniqueIndex)
            const localVarPath = `/v1/members/{uniqueIndex}`
                .replace(`{${"uniqueIndex"}}`, encodeURIComponent(String(uniqueIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (club !== undefined) {
                localVarQueryParameter['club'] = club;
            }

            if (nameSearch !== undefined) {
                localVarQueryParameter['nameSearch'] = nameSearch;
            }

            if (extendedInformation !== undefined) {
                localVarQueryParameter['extendedInformation'] = extendedInformation;
            }

            if (rankingPointsInformation !== undefined) {
                localVarQueryParameter['rankingPointsInformation'] = rankingPointsInformation;
            }

            if (withResults !== undefined) {
                localVarQueryParameter['withResults'] = withResults;
            }

            if (withOpponentRankingEvaluation !== undefined) {
                localVarQueryParameter['withOpponentRankingEvaluation'] = withOpponentRankingEvaluation;
            }

            if (playerCategory !== undefined) {
                localVarQueryParameter['playerCategory'] = playerCategory;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uniqueIndex 
         * @param {string} shortNameSearch 
         * @param {string} rankingCategory 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberCategoriesV1: async (uniqueIndex: string, shortNameSearch: string, rankingCategory: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueIndex' is not null or undefined
            assertParamExists('findMemberCategoriesV1', 'uniqueIndex', uniqueIndex)
            // verify required parameter 'shortNameSearch' is not null or undefined
            assertParamExists('findMemberCategoriesV1', 'shortNameSearch', shortNameSearch)
            // verify required parameter 'rankingCategory' is not null or undefined
            assertParamExists('findMemberCategoriesV1', 'rankingCategory', rankingCategory)
            const localVarPath = `/v1/members/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uniqueIndex !== undefined) {
                localVarQueryParameter['uniqueIndex'] = uniqueIndex;
            }

            if (shortNameSearch !== undefined) {
                localVarQueryParameter['shortNameSearch'] = shortNameSearch;
            }

            if (rankingCategory !== undefined) {
                localVarQueryParameter['rankingCategory'] = rankingCategory;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} uniqueIndex 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberNumericRankingsHistoryV1: async (uniqueIndex: number, category: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueIndex' is not null or undefined
            assertParamExists('findMemberNumericRankingsHistoryV1', 'uniqueIndex', uniqueIndex)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('findMemberNumericRankingsHistoryV1', 'category', category)
            const localVarPath = `/v1/members/{uniqueIndex}/numeric-rankings`
                .replace(`{${"uniqueIndex"}}`, encodeURIComponent(String(uniqueIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [club] 
         * @param {number} [uniqueIndex] 
         * @param {string} [nameSearch] 
         * @param {boolean} [extendedInformation] 
         * @param {boolean} [rankingPointsInformation] 
         * @param {boolean} [withResults] 
         * @param {boolean} [withOpponentRankingEvaluation] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} [playerCategory] 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllMembersV1(club?: string, uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberEntryDTOV1>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllMembersV1(club, uniqueIndex, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, playerCategory, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} uniqueIndex 
         * @param {string} [club] 
         * @param {string} [nameSearch] 
         * @param {boolean} [extendedInformation] 
         * @param {boolean} [rankingPointsInformation] 
         * @param {boolean} [withResults] 
         * @param {boolean} [withOpponentRankingEvaluation] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} [playerCategory] 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMemberByIdV1(uniqueIndex: number, club?: string, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberEntryDTOV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMemberByIdV1(uniqueIndex, club, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, playerCategory, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uniqueIndex 
         * @param {string} shortNameSearch 
         * @param {string} rankingCategory 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMemberCategoriesV1(uniqueIndex: string, shortNameSearch: string, rankingCategory: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemberEntryDTOV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMemberCategoriesV1(uniqueIndex, shortNameSearch, rankingCategory, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} uniqueIndex 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMemberNumericRankingsHistoryV1(uniqueIndex: number, category: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WeeklyNumericPointsV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMemberNumericRankingsHistoryV1(uniqueIndex, category, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [club] 
         * @param {number} [uniqueIndex] 
         * @param {string} [nameSearch] 
         * @param {boolean} [extendedInformation] 
         * @param {boolean} [rankingPointsInformation] 
         * @param {boolean} [withResults] 
         * @param {boolean} [withOpponentRankingEvaluation] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} [playerCategory] 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllMembersV1(club?: string, uniqueIndex?: number, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<Array<MemberEntryDTOV1>> {
            return localVarFp.findAllMembersV1(club, uniqueIndex, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, playerCategory, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} uniqueIndex 
         * @param {string} [club] 
         * @param {string} [nameSearch] 
         * @param {boolean} [extendedInformation] 
         * @param {boolean} [rankingPointsInformation] 
         * @param {boolean} [withResults] 
         * @param {boolean} [withOpponentRankingEvaluation] 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} [playerCategory] 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberByIdV1(uniqueIndex: number, club?: string, nameSearch?: string, extendedInformation?: boolean, rankingPointsInformation?: boolean, withResults?: boolean, withOpponentRankingEvaluation?: boolean, playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<MemberEntryDTOV1> {
            return localVarFp.findMemberByIdV1(uniqueIndex, club, nameSearch, extendedInformation, rankingPointsInformation, withResults, withOpponentRankingEvaluation, playerCategory, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uniqueIndex 
         * @param {string} shortNameSearch 
         * @param {string} rankingCategory 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberCategoriesV1(uniqueIndex: string, shortNameSearch: string, rankingCategory: string, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<MemberEntryDTOV1> {
            return localVarFp.findMemberCategoriesV1(uniqueIndex, shortNameSearch, rankingCategory, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} uniqueIndex 
         * @param {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'} category 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberNumericRankingsHistoryV1(uniqueIndex: number, category: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W', options?: any): AxiosPromise<WeeklyNumericPointsV1> {
            return localVarFp.findMemberNumericRankingsHistoryV1(uniqueIndex, category, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAllMembersV1 operation in MembersApi.
 * @export
 * @interface MembersApiFindAllMembersV1Request
 */
export interface MembersApiFindAllMembersV1Request {
    /**
     * 
     * @type {string}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly club?: string

    /**
     * 
     * @type {number}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly uniqueIndex?: number

    /**
     * 
     * @type {string}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly nameSearch?: string

    /**
     * 
     * @type {boolean}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly extendedInformation?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly rankingPointsInformation?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly withResults?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly withOpponentRankingEvaluation?: boolean

    /**
     * 
     * @type {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'

    /**
     * Account to do a request
     * @type {string}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MembersApiFindAllMembersV1
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findMemberByIdV1 operation in MembersApi.
 * @export
 * @interface MembersApiFindMemberByIdV1Request
 */
export interface MembersApiFindMemberByIdV1Request {
    /**
     * 
     * @type {number}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly uniqueIndex: number

    /**
     * 
     * @type {string}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly club?: string

    /**
     * 
     * @type {string}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly nameSearch?: string

    /**
     * 
     * @type {boolean}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly extendedInformation?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly rankingPointsInformation?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly withResults?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly withOpponentRankingEvaluation?: boolean

    /**
     * 
     * @type {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly playerCategory?: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'

    /**
     * Account to do a request
     * @type {string}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MembersApiFindMemberByIdV1
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findMemberCategoriesV1 operation in MembersApi.
 * @export
 * @interface MembersApiFindMemberCategoriesV1Request
 */
export interface MembersApiFindMemberCategoriesV1Request {
    /**
     * 
     * @type {string}
     * @memberof MembersApiFindMemberCategoriesV1
     */
    readonly uniqueIndex: string

    /**
     * 
     * @type {string}
     * @memberof MembersApiFindMemberCategoriesV1
     */
    readonly shortNameSearch: string

    /**
     * 
     * @type {string}
     * @memberof MembersApiFindMemberCategoriesV1
     */
    readonly rankingCategory: string

    /**
     * Account to do a request
     * @type {string}
     * @memberof MembersApiFindMemberCategoriesV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof MembersApiFindMemberCategoriesV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof MembersApiFindMemberCategoriesV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof MembersApiFindMemberCategoriesV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof MembersApiFindMemberCategoriesV1
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findMemberNumericRankingsHistoryV1 operation in MembersApi.
 * @export
 * @interface MembersApiFindMemberNumericRankingsHistoryV1Request
 */
export interface MembersApiFindMemberNumericRankingsHistoryV1Request {
    /**
     * 
     * @type {number}
     * @memberof MembersApiFindMemberNumericRankingsHistoryV1
     */
    readonly uniqueIndex: number

    /**
     * 
     * @type {'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'}
     * @memberof MembersApiFindMemberNumericRankingsHistoryV1
     */
    readonly category: 'SEN_M' | 'SEN_W' | 'YOU_M' | 'YOU_W' | 'VET_M' | 'VET_W' | 'BEN_M' | 'BEN_W' | 'PRE_M' | 'PRE_W' | 'MIN_M' | 'MIN_W' | 'CAD_M' | 'CAD_W' | 'JUN_M' | 'JUN_W' | 'J19_M' | 'J19_W' | 'V40_M' | 'V40_W' | 'V50_M' | 'V50_W' | 'V60_M' | 'V60_W' | 'V65_M' | 'V65_W' | 'V70_M' | 'V70_W' | 'V75_M' | 'V75_W' | 'V80_M' | 'V80_W' | 'V85_M' | 'V85_W'
}

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @param {MembersApiFindAllMembersV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findAllMembersV1(requestParameters: MembersApiFindAllMembersV1Request = {}, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).findAllMembersV1(requestParameters.club, requestParameters.uniqueIndex, requestParameters.nameSearch, requestParameters.extendedInformation, requestParameters.rankingPointsInformation, requestParameters.withResults, requestParameters.withOpponentRankingEvaluation, requestParameters.playerCategory, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MembersApiFindMemberByIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findMemberByIdV1(requestParameters: MembersApiFindMemberByIdV1Request, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).findMemberByIdV1(requestParameters.uniqueIndex, requestParameters.club, requestParameters.nameSearch, requestParameters.extendedInformation, requestParameters.rankingPointsInformation, requestParameters.withResults, requestParameters.withOpponentRankingEvaluation, requestParameters.playerCategory, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MembersApiFindMemberCategoriesV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findMemberCategoriesV1(requestParameters: MembersApiFindMemberCategoriesV1Request, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).findMemberCategoriesV1(requestParameters.uniqueIndex, requestParameters.shortNameSearch, requestParameters.rankingCategory, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MembersApiFindMemberNumericRankingsHistoryV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public findMemberNumericRankingsHistoryV1(requestParameters: MembersApiFindMemberNumericRankingsHistoryV1Request, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).findMemberNumericRankingsHistoryV1(requestParameters.uniqueIndex, requestParameters.category, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search across members, clubs, and tournaments
         * @param {string} q Search query string
         * @param {string} [types] Comma-separated list of types to search (member,club,tournament). If not provided, searches all types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearch: async (q: string, types?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchControllerSearch', 'q', q)
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search across members, clubs, and tournaments
         * @param {string} q Search query string
         * @param {string} [types] Comma-separated list of types to search (member,club,tournament). If not provided, searches all types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchControllerSearch(q: string, types?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResultDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchControllerSearch(q, types, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * 
         * @summary Search across members, clubs, and tournaments
         * @param {string} q Search query string
         * @param {string} [types] Comma-separated list of types to search (member,club,tournament). If not provided, searches all types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchControllerSearch(q: string, types?: string, options?: any): AxiosPromise<SearchResultDTO> {
            return localVarFp.searchControllerSearch(q, types, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchControllerSearch operation in SearchApi.
 * @export
 * @interface SearchApiSearchControllerSearchRequest
 */
export interface SearchApiSearchControllerSearchRequest {
    /**
     * Search query string
     * @type {string}
     * @memberof SearchApiSearchControllerSearch
     */
    readonly q: string

    /**
     * Comma-separated list of types to search (member,club,tournament). If not provided, searches all types.
     * @type {string}
     * @memberof SearchApiSearchControllerSearch
     */
    readonly types?: string
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @summary Search across members, clubs, and tournaments
     * @param {SearchApiSearchControllerSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchControllerSearch(requestParameters: SearchApiSearchControllerSearchRequest, options?: AxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchControllerSearch(requestParameters.q, requestParameters.types, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SeasonsApi - axios parameter creator
 * @export
 */
export const SeasonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSeason: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/seasons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCurrentSeason: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/seasons/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} seasonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeasonById: async (seasonId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seasonId' is not null or undefined
            assertParamExists('findSeasonById', 'seasonId', seasonId)
            const localVarPath = `/v1/seasons/{seasonId}`
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SeasonsApi - functional programming interface
 * @export
 */
export const SeasonsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SeasonsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllSeason(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SeasonDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllSeason(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCurrentSeason(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeasonDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCurrentSeason(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} seasonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSeasonById(seasonId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeasonDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSeasonById(seasonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SeasonsApi - factory interface
 * @export
 */
export const SeasonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SeasonsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSeason(options?: any): AxiosPromise<Array<SeasonDto>> {
            return localVarFp.findAllSeason(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCurrentSeason(options?: any): AxiosPromise<SeasonDto> {
            return localVarFp.findCurrentSeason(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} seasonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeasonById(seasonId: number, options?: any): AxiosPromise<SeasonDto> {
            return localVarFp.findSeasonById(seasonId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findSeasonById operation in SeasonsApi.
 * @export
 * @interface SeasonsApiFindSeasonByIdRequest
 */
export interface SeasonsApiFindSeasonByIdRequest {
    /**
     * 
     * @type {number}
     * @memberof SeasonsApiFindSeasonById
     */
    readonly seasonId: number
}

/**
 * SeasonsApi - object-oriented interface
 * @export
 * @class SeasonsApi
 * @extends {BaseAPI}
 */
export class SeasonsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonsApi
     */
    public findAllSeason(options?: AxiosRequestConfig) {
        return SeasonsApiFp(this.configuration).findAllSeason(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonsApi
     */
    public findCurrentSeason(options?: AxiosRequestConfig) {
        return SeasonsApiFp(this.configuration).findCurrentSeason(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SeasonsApiFindSeasonByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SeasonsApi
     */
    public findSeasonById(requestParameters: SeasonsApiFindSeasonByIdRequest, options?: AxiosRequestConfig) {
        return SeasonsApiFp(this.configuration).findSeasonById(requestParameters.seasonId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TournamentsApi - axios parameter creator
 * @export
 */
export const TournamentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTournamentsV1: async (xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tournaments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} tournamentId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeriesByTournamentV1: async (tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tournamentId' is not null or undefined
            assertParamExists('findSeriesByTournamentV1', 'tournamentId', tournamentId)
            const localVarPath = `/v1/tournaments/{tournamentId}/series`
                .replace(`{${"tournamentId"}}`, encodeURIComponent(String(tournamentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} tournamentId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {boolean} [withResults] 
         * @param {boolean} [withRegistrations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTournamentByIdV1: async (tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, withResults?: boolean, withRegistrations?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tournamentId' is not null or undefined
            assertParamExists('findTournamentByIdV1', 'tournamentId', tournamentId)
            const localVarPath = `/v1/tournaments/{tournamentId}`
                .replace(`{${"tournamentId"}}`, encodeURIComponent(String(tournamentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withResults !== undefined) {
                localVarQueryParameter['withResults'] = withResults;
            }

            if (withRegistrations !== undefined) {
                localVarQueryParameter['withRegistrations'] = withRegistrations;
            }

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} tournamentId 
         * @param {number} serieId 
         * @param {RegisterTournament} registerTournament 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerToSerieV1: async (tournamentId: number, serieId: number, registerTournament: RegisterTournament, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tournamentId' is not null or undefined
            assertParamExists('registerToSerieV1', 'tournamentId', tournamentId)
            // verify required parameter 'serieId' is not null or undefined
            assertParamExists('registerToSerieV1', 'serieId', serieId)
            // verify required parameter 'registerTournament' is not null or undefined
            assertParamExists('registerToSerieV1', 'registerTournament', registerTournament)
            const localVarPath = `/v1/tournaments/{tournamentId}/serie/{serieId}/register`
                .replace(`{${"tournamentId"}}`, encodeURIComponent(String(tournamentId)))
                .replace(`{${"serieId"}}`, encodeURIComponent(String(serieId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xTabtAccount !== undefined && xTabtAccount !== null) {
                localVarHeaderParameter['X-Tabt-Account'] = String(xTabtAccount);
            }

            if (xTabtPassword !== undefined && xTabtPassword !== null) {
                localVarHeaderParameter['X-Tabt-Password'] = String(xTabtPassword);
            }

            if (xTabtOnBehalfOf !== undefined && xTabtOnBehalfOf !== null) {
                localVarHeaderParameter['X-Tabt-OnBehalfOf'] = String(xTabtOnBehalfOf);
            }

            if (xTabtDatabase !== undefined && xTabtDatabase !== null) {
                localVarHeaderParameter['X-Tabt-Database'] = String(xTabtDatabase);
            }

            if (xTabtSeason !== undefined && xTabtSeason !== null) {
                localVarHeaderParameter['X-Tabt-Season'] = String(xTabtSeason);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerTournament, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TournamentsApi - functional programming interface
 * @export
 */
export const TournamentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TournamentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllTournamentsV1(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TournamentEntryDTOV1>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllTournamentsV1(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} tournamentId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSeriesByTournamentV1(tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TournamentSerieEntryDTOV1>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSeriesByTournamentV1(tournamentId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} tournamentId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {boolean} [withResults] 
         * @param {boolean} [withRegistrations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTournamentByIdV1(tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, withResults?: boolean, withRegistrations?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TournamentEntryDTOV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTournamentByIdV1(tournamentId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, withResults, withRegistrations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} tournamentId 
         * @param {number} serieId 
         * @param {RegisterTournament} registerTournament 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerToSerieV1(tournamentId: number, serieId: number, registerTournament: RegisterTournament, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerToSerieV1(tournamentId, serieId, registerTournament, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TournamentsApi - factory interface
 * @export
 */
export const TournamentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TournamentsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTournamentsV1(xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<Array<TournamentEntryDTOV1>> {
            return localVarFp.findAllTournamentsV1(xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} tournamentId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeriesByTournamentV1(tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<Array<TournamentSerieEntryDTOV1>> {
            return localVarFp.findSeriesByTournamentV1(tournamentId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} tournamentId 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {boolean} [withResults] 
         * @param {boolean} [withRegistrations] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTournamentByIdV1(tournamentId: number, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, withResults?: boolean, withRegistrations?: boolean, options?: any): AxiosPromise<TournamentEntryDTOV1> {
            return localVarFp.findTournamentByIdV1(tournamentId, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, withResults, withRegistrations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} tournamentId 
         * @param {number} serieId 
         * @param {RegisterTournament} registerTournament 
         * @param {string} [xTabtAccount] Account to do a request
         * @param {string} [xTabtPassword] Password of the account
         * @param {string} [xTabtOnBehalfOf] On Behalf of
         * @param {'aftt' | 'vttl'} [xTabtDatabase] Database to query
         * @param {string} [xTabtSeason] Season name to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerToSerieV1(tournamentId: number, serieId: number, registerTournament: RegisterTournament, xTabtAccount?: string, xTabtPassword?: string, xTabtOnBehalfOf?: string, xTabtDatabase?: 'aftt' | 'vttl', xTabtSeason?: string, options?: any): AxiosPromise<void> {
            return localVarFp.registerToSerieV1(tournamentId, serieId, registerTournament, xTabtAccount, xTabtPassword, xTabtOnBehalfOf, xTabtDatabase, xTabtSeason, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for findAllTournamentsV1 operation in TournamentsApi.
 * @export
 * @interface TournamentsApiFindAllTournamentsV1Request
 */
export interface TournamentsApiFindAllTournamentsV1Request {
    /**
     * Account to do a request
     * @type {string}
     * @memberof TournamentsApiFindAllTournamentsV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof TournamentsApiFindAllTournamentsV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof TournamentsApiFindAllTournamentsV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof TournamentsApiFindAllTournamentsV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof TournamentsApiFindAllTournamentsV1
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findSeriesByTournamentV1 operation in TournamentsApi.
 * @export
 * @interface TournamentsApiFindSeriesByTournamentV1Request
 */
export interface TournamentsApiFindSeriesByTournamentV1Request {
    /**
     * 
     * @type {number}
     * @memberof TournamentsApiFindSeriesByTournamentV1
     */
    readonly tournamentId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof TournamentsApiFindSeriesByTournamentV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof TournamentsApiFindSeriesByTournamentV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof TournamentsApiFindSeriesByTournamentV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof TournamentsApiFindSeriesByTournamentV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof TournamentsApiFindSeriesByTournamentV1
     */
    readonly xTabtSeason?: string
}

/**
 * Request parameters for findTournamentByIdV1 operation in TournamentsApi.
 * @export
 * @interface TournamentsApiFindTournamentByIdV1Request
 */
export interface TournamentsApiFindTournamentByIdV1Request {
    /**
     * 
     * @type {number}
     * @memberof TournamentsApiFindTournamentByIdV1
     */
    readonly tournamentId: number

    /**
     * Account to do a request
     * @type {string}
     * @memberof TournamentsApiFindTournamentByIdV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof TournamentsApiFindTournamentByIdV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof TournamentsApiFindTournamentByIdV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof TournamentsApiFindTournamentByIdV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof TournamentsApiFindTournamentByIdV1
     */
    readonly xTabtSeason?: string

    /**
     * 
     * @type {boolean}
     * @memberof TournamentsApiFindTournamentByIdV1
     */
    readonly withResults?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TournamentsApiFindTournamentByIdV1
     */
    readonly withRegistrations?: boolean
}

/**
 * Request parameters for registerToSerieV1 operation in TournamentsApi.
 * @export
 * @interface TournamentsApiRegisterToSerieV1Request
 */
export interface TournamentsApiRegisterToSerieV1Request {
    /**
     * 
     * @type {number}
     * @memberof TournamentsApiRegisterToSerieV1
     */
    readonly tournamentId: number

    /**
     * 
     * @type {number}
     * @memberof TournamentsApiRegisterToSerieV1
     */
    readonly serieId: number

    /**
     * 
     * @type {RegisterTournament}
     * @memberof TournamentsApiRegisterToSerieV1
     */
    readonly registerTournament: RegisterTournament

    /**
     * Account to do a request
     * @type {string}
     * @memberof TournamentsApiRegisterToSerieV1
     */
    readonly xTabtAccount?: string

    /**
     * Password of the account
     * @type {string}
     * @memberof TournamentsApiRegisterToSerieV1
     */
    readonly xTabtPassword?: string

    /**
     * On Behalf of
     * @type {string}
     * @memberof TournamentsApiRegisterToSerieV1
     */
    readonly xTabtOnBehalfOf?: string

    /**
     * Database to query
     * @type {'aftt' | 'vttl'}
     * @memberof TournamentsApiRegisterToSerieV1
     */
    readonly xTabtDatabase?: 'aftt' | 'vttl'

    /**
     * Season name to query
     * @type {string}
     * @memberof TournamentsApiRegisterToSerieV1
     */
    readonly xTabtSeason?: string
}

/**
 * TournamentsApi - object-oriented interface
 * @export
 * @class TournamentsApi
 * @extends {BaseAPI}
 */
export class TournamentsApi extends BaseAPI {
    /**
     * 
     * @param {TournamentsApiFindAllTournamentsV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public findAllTournamentsV1(requestParameters: TournamentsApiFindAllTournamentsV1Request = {}, options?: AxiosRequestConfig) {
        return TournamentsApiFp(this.configuration).findAllTournamentsV1(requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TournamentsApiFindSeriesByTournamentV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public findSeriesByTournamentV1(requestParameters: TournamentsApiFindSeriesByTournamentV1Request, options?: AxiosRequestConfig) {
        return TournamentsApiFp(this.configuration).findSeriesByTournamentV1(requestParameters.tournamentId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TournamentsApiFindTournamentByIdV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public findTournamentByIdV1(requestParameters: TournamentsApiFindTournamentByIdV1Request, options?: AxiosRequestConfig) {
        return TournamentsApiFp(this.configuration).findTournamentByIdV1(requestParameters.tournamentId, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, requestParameters.withResults, requestParameters.withRegistrations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TournamentsApiRegisterToSerieV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TournamentsApi
     */
    public registerToSerieV1(requestParameters: TournamentsApiRegisterToSerieV1Request, options?: AxiosRequestConfig) {
        return TournamentsApiFp(this.configuration).registerToSerieV1(requestParameters.tournamentId, requestParameters.serieId, requestParameters.registerTournament, requestParameters.xTabtAccount, requestParameters.xTabtPassword, requestParameters.xTabtOnBehalfOf, requestParameters.xTabtDatabase, requestParameters.xTabtSeason, options).then((request) => request(this.axios, this.basePath));
    }
}


